# 算法

## 1.数据结构线性表面试题

### 1.什么是线性表，java中有哪些线性表？

线性表是一种数据结构，由n个数据元素组成的有限序列，其中数据元素之间存在线性关系，即除了第一个和最后一个元素外，每个元素都有且只有一个直接前驱和直接后继。

在 Java 中，线性表是通过接口实现的。下面是 Java 中线性表相关的接口和类：

**List 接口**：代表了一个有序、可重复的序列，其中每个元素都有一个整数索引。它是 Collection 接口的子接口。

**ArrayList 类**：是 List 接口的一种实现，它使用数组来存储元素，支持快速随机访问元素。

**LinkedList 类**：也是 List 接口的一种实现，它使用链表来存储元素，支持快速在列表开头和结尾进行插入和删除操作。

**Vector 类**：与 ArrayList 类似，它也是 List 接口的一种实现，但是它是线程安全的。

**Stack 类**：代表了一个后进先出（LIFO）的栈，它继承自 Vector 类。

除此之外，Java 还提供了 Queue 接口和 Deque 接口，它们代表了队列和双端队列，也可以用来实现线性表。其中 LinkedList 类也可以用作队列和双端队列的实现。

### 2.线性表有哪些常见的存储方式？

线性表是一种常见的数据结构，常见的存储方式包括以下几种：

**数组存储**：将线性表中的元素依次存储在一段连续的内存空间中。数组的存取速度较快，但是插入和删除操作的时间复杂度较高。

**链式存储**：将线性表中的元素存储在不同的物理地址中，通过指针链接起来。链式存储的插入和删除操作较为灵活，但是访问元素时需要遍历链表，速度较慢。

**静态链表**：静态链表是利用数组模拟链表的存储结构，即使用数组来存储节点，通过数组下标来访问节点，使用指针来链接节点。静态链表的空间利用率高，但是容量固定，不能动态扩容。

**循环数组存储**：将线性表中的元素存储在一个循环数组中，通过下标访问元素。循环数组的存取速度较快，可以很方便地实现队列和栈等数据结构，但是插入和删除操作的时间复杂度较高。

**块状链表**：将线性表分成若干块，每块用链表存储。块状链表可以支持高效的块间操作，如合并、分裂等，但是实现较为复杂。

### 3.线性表的常见操作有哪些？

**插入操作**：在线性表中插入一个元素。

**删除操作**：从线性表中删除一个元素。

**查找操作**：在线性表中查找指定元素，并返回其位置或者值。

**修改操作**：修改线性表中指定位置的元素值。

**遍历操作**：依次访问线性表中的所有元素。

**合并操作**：将两个线性表合并成一个线性表。

**截取操作**：从线性表中截取出一个子表。

**排序操作**：将线性表中的元素按照一定的规则排序。

**清空操作**：清空线性表中的所有元素。

以上这些操作是线性表的基本操作，在实际应用中还会根据需要进行一些其他的操作。其中，插入、删除、查找、修改、遍历等操作是线性表中最常用的操作。

### 4.如何实现一个动态数组？请简述动态数组的特点和实现方法。

**1.** 创建一个DynamicArray类，该类包含三个成员变量：capacity（容量）、size（元素个数）和array（存储元素的数组）。

**2.** 定义构造函数，初始化容量为10，元素个数为0，数组长度为10。

**3.** 定义resize方法，用于扩容和缩容操作。当元素个数等于容量时，扩容为原来的两倍；当元素个数小于容量的一半时，缩容为原来的一半。

**4.** 定义add方法，用于向动态数组末尾添加元素。如果元素个数等于容量，先调用resize方法进行扩容。

**5.** 定义remove方法，用于从动态数组末尾删除元素并返回删除的元素。如果元素个数小于容量的一半，先调用resize方法进行缩容。

**6.** 使用泛型实现DynamicArray类，支持存储任意类型的元素。
编写测试代码，验证DynamicArray类的各个方法是否能够正常工作。

```java
    public class DynamicArray<E> {
        private int capacity;
        private int size;
        private Object[] array;

        public DynamicArray() {
            capacity = 10;
            size = 0;
            array = new Object[capacity];
        }

        public void resize(int newCapacity) {
            Object[] newArray = new Object[newCapacity];
            for (int i = 0; i < size; i++) {
                newArray[i] = array[i];
            }
            array = newArray;
            capacity = newCapacity;
        }

        public void add(E element) {
            if (size == capacity) {
                resize(2 * capacity);
            }
            array[size] = element;
            size++;
        }

        public E remove() {
            if (size == 0) {
                throw new RuntimeException("Array is empty.");
            }
            E element = (E) array[size - 1];
            size--;
            if (size < capacity / 2) {
                resize(capacity / 2);
            }
        return element;
        }
    }
```

### 5.如何判断一个链表中是否存在环？请给出相应的算法及其时间复杂度。

判断一个链表中是否存在环可以使用双指针法，也称为快慢指针法，具体算法如下：

**1.** 定义两个指针slow和fast，初始值均指向链表头部。

**2.** slow指针每次移动一个节点，fast指针每次移动两个节点，直到fast指针指向链表尾部，或者slow指针和fast指针相遇。

**3.** 如果fast指针指向链表尾部，说明链表中没有环；如果slow指针和fast指针相遇，说明链表中存在环。

相应的时间复杂度为O(n)，其中n为链表中节点的个数，因为快指针最多会遍历整个链表，而慢指针最多只会遍历一半链表，所以时间复杂度为线性。

```java
    public class ListNode {
        int val;
        ListNode next;
        ListNode(int x) {
            val = x;
            next = null;
        }
    }

    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }
        ListNode slow = head;
        ListNode fast = head.next;
        while (slow != fast) {
            if (fast == null || fast.next == null) {
                return false;
            }
            slow = slow.next;
            fast = fast.next.next;
        }
        return true;
    }
```

hasCycle方法实现了使用双指针法判断链表中是否存在环的功能。在方法中，首先判断链表是否为空或只有一个节点，如果是，则返回false。

然后定义慢指针和快指针，分别指向链表头部和头部的下一个节点。在while循环中，如果快指针指向null或者快指针的下一个节点指向null，则说明链表中不存在环，返回false；

否则，慢指针每次移动一个节点，快指针每次移动两个节点，直到两个指针相遇，说明链表中存在环，返回true。

### 6.如何实现一个循环队列？请简述循环队列的基本操作及其时间复杂度。

循环队列是一种常用的队列实现方式，它通过循环利用数组空间来实现队列的基本操作。循环队列中，队尾指针和队头指针都可以循环移动，可以高效地实现入队和出队操作。

循环队列的基本操作包括：

**1.初始化操作：** 创建一个空的循环队列，需要指定队列的最大容量。

**2.入队操作：** 将元素添加到队尾，如果队列已满则无法添加。

**3.出队操作：** 从队头删除元素并返回该元素，如果队列为空则无法删除。

**4.获取队列头部元素：** 获取队头元素，但不删除该元素，如果队列为空则返回null。

**5.判断队列是否为空：** 判断队列中是否有元素。

**6.判断队列是否已满：** 判断队列是否已满，如果队列已满则无法添加元素。

```java
    public class CircularQueue {
        private int[] queue;     // 存储队列元素的数组
        private int front;       // 队头指针
        private int rear;        // 队尾指针
        private int size;        // 队列元素个数
        private int capacity;    // 队列容量

        // 初始化队列
        public CircularQueue(int k) {
            capacity = k;
            queue = new int[capacity];
            front = 0;
            rear = 0;
            size = 0;
        }

        // 入队操作
        public boolean enqueue(int value) {
            if (isFull()) {
                return false;
            }
            queue[rear] = value;
            rear = (rear + 1) % capacity;   // rear指针循环移动
            size++;
            return true;
        }

        // 出队操作
        public int dequeue() {
            if (isEmpty()) {
                return -1;
            }
            int value = queue[front];
            front = (front + 1) % capacity;  // front指针循环移动
            size--;
            return value;
        }

        // 获取队头元素
        public int getFront() {
            if (isEmpty()) {
                return -1;
            }
            return queue[front];
        }

        // 判断队列是否为空
        public boolean isEmpty() {
            return size == 0;
        }

        // 判断队列是否已满
        public boolean isFull() {
            return size == capacity;
        }
    }
```

### 7.如何实现一个哈希表？请简述哈希表的实现原理和冲突解决方法。

哈希表是一种常用的数据结构，用于快速查找和插入数据。它的核心思想是将每个元素的关键字映射到一个唯一的位置上，这个位置就是哈希值。

哈希表通过哈希函数将元素的关键字转化为哈希值，并将其存储在数组中对应的位置上。当需要查找或插入一个元素时，哈希表使用相同的哈希函数将关键字转化为哈希值，并在数组中查找对应的位置，这样可以快速定位到元素的位置，提高了查找和插入的效率。

**哈希表的实现原理**：

**哈希函数**：哈希函数是将元素的关键字转化为哈希值的算法，它应该满足以下条件：

**a**. 输出的哈希值是一个非负整数。

**b**. 输入相同的关键字应该得到相同的哈希值。

**c**. 输入不同的关键字应该得到不同的哈希值。

**数组**：哈希表通过数组来存储元素。数组的大小应该足够大，以容纳所有可能的元素。

**冲突处理**：由于哈希函数可能会将不同的关键字映射到同一个位置上，所以在插入元素时可能会出现冲突。哈希表通过不同的冲突解决方法来处理冲突。

**哈希表的冲突解决方法**：

**开放地址法**：在出现冲突时，通过寻找其他空闲的位置来解决冲突。常用的开放地址法有线性探测法、二次探测法和双重哈希法。

**链地址法**：在出现冲突时，将冲突的元素存储在同一个位置上，并用链表来解决冲突。链地址法是最常用的冲突解决方法。

**其他方法**：还有其他的冲突解决方法，如建立公共溢出区、再哈希法等，但不如前两种方法常用。

**实现哈希表的步骤**：

**1.** 定义哈希表的数据结构：包括数组、哈希函数等。

**2.** 实现哈希函数：根据具体的需求选择合适的哈希函数，将元素的关键字转化为哈希值。

**3.** 实现插入、删除和查找操作：根据不同的冲突解决方法，实现相应的操作。在插入时，需要先计算出元素的哈希值，然后根据冲突解决方法来确定插入的位置。在查找和删除时，也需要计算出元素

**链地址法实现的哈希表**

```java
    class Node {
        int key;
        String value;
        Node next;

        public Node(int key, String value) {
            this.key = key;
            this.value = value;
            this.next = null;
        }
    }

    class MyHashMap {
        private static final int SIZE = 1000;
        private Node[] table;

        public MyHashMap() {
            table = new Node[SIZE];
        }

        public void put(int key, String value) {
            int index = hash(key);
            Node node = table[index];

             while (node != null) {
                if (node.key == key) {
                    node.value = value;
                    return;
                }
                node = node.next;
            }

            Node newNode = new Node(key, value);
            newNode.next = table[index];
            table[index] = newNode;
        }

        public String get(int key) {
            int index = hash(key);
            Node node = table[index];

            while (node != null) {
                 if (node.key == key) {
                    return node.value;
                }
                node = node.next;
            }

            return null;
        }

        public void remove(int key) {
            int index = hash(key);
            Node node = table[index];
            Node prev = null;
    
            while (node != null) {
                if (node.key == key) {
                    if (prev == null) {
                        table[index] = node.next;
                    } else {
                        prev.next = node.next;
                    }
                    return;
                }
                prev = node;
                node = node.next;
            }    
        }

        private int hash(int key) {
            return key % SIZE;
        }
    }
```

在这个实现中，使用了链表来解决冲突。每个节点包括一个键值对和一个指向下一个节点的指针。

哈希表使用一个固定大小的数组来存储链表头节点。

在插入时，根据键的哈希值计算出数组下标，然后在相应的链表中查找是否已经存在相同的键，如果存在则更新其值，否则将新节点插入到链表的头部。

在查找和删除时也是类似的流程。

### 8.如何实现一个堆？请简述堆的基本操作及其时间复杂度。

> 堆（Heap）是一种基于完全二叉树的数据结构，其中每个节点的值都不大于
> （或不小于）其子节点的值，被称为最大堆（Max Heap）或最小堆（Min Heap）。

**堆的基本操作包括**：

**插入操作**：将一个元素插入到堆中，需要保证插入后仍然满足堆的性质。

**删除操作**：删除堆中的最大元素（最小元素），需要保证删除后仍然满足堆的性质。

**查找操作**：查找堆中的最大元素（最小元素），时间复杂度为 O(1)。

**堆的时间复杂度如下**：

**插入操作:** 时间复杂度为 O(log n)，其中 n 是堆中元素的个数。

**删除操作:** 时间复杂度为 O(log n)，其中 n 是堆中元素的个数。

**查找操作:** 时间复杂度为 O(1)。

```java
    class MaxHeap {
        private int[] heap;
        private int size;
        private int capacity;

        public MaxHeap(int capacity) {
            heap = new int[capacity];
            size = 0;
            this.capacity = capacity;
        }

        public void insert(int x) {
            if (size == capacity) {
                return;
            }

            heap[size] = x;
            size++;

            int i = size - 1;
            while (i > 0 && heap[i] > heap[(i - 1) / 2]) {
                swap(i, (i - 1) / 2);
                i = (i - 1) / 2;
            }
        }

        public int removeMax() {
            if (size == 0) {
                return -1;
            }

            int max = heap[0];
            size--;

            heap[0] = heap[size];
            heap[size] = 0;

            int i = 0;
            while (true) {
                int left = i * 2 + 1;
                int right = i * 2 + 2;
                int largest = i;

                if (left < size && heap[left] > heap[largest]) {
                    largest = left;
                }

                if (right < size && heap[right] > heap[largest]) {
                    largest = right;
                }

                if (largest != i) {
                    swap(i, largest);
                    i = largest;
                } else {
                    break;
                }
            }

            return max;
        }    

        private void swap(int i, int j) {
            int temp = heap[i];
            heap[i] = heap[j];
            heap[j] = temp;
        }
    }
```

### 9.如何实现一个优先队列？请简述优先队列的实现方法及其时间复杂度。

优先队列是一种能够维护元素优先级的数据结构，每次从队列中取出的元素都是优先级最高（或最低）的元素。常见的实现方法包括堆、二叉搜索树等。

其中，基于堆实现的优先队列被称为堆（Heap）优先队列，也是最常见的实现方式。堆优先队列可以通过最大堆（Max Heap）或最小堆（Min Heap）来实现。

**堆优先队列的基本操作包括：**

**插入操作:** 将一个元素插入到队列中，需要保证插入后仍然满足堆的性质。

**删除操作:** 删除队列中的最大元素（最小元素），需要保证删除后仍然满足堆的性质。

**查找操作:** 查找队列中的最大元素（最小元素），时间复杂度为 O(1)。

堆优先队列的时间复杂度如下：

**插入操作:** 时间复杂度为 O(log n)，其中 n 是队列中元素的个数。

**删除操作:** 时间复杂度为 O(log n)，其中 n 是队列中元素的个数。

**查找操作:** 时间复杂度为 O(1)。

下面是一个简单的使用 Java 中的 PriorityQueue 类实现堆优先队列的示例代码：

```java
    import java.util.PriorityQueue;

    public class PriorityQueueExample {
        public static void main(String[] args) {
            PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);

            pq.offer(3);
            pq.offer(1);
            pq.offer(4);
            pq.offer(2);
    
            while (!pq.isEmpty()) {
                System.out.println(pq.poll());
            }
        }
    }  
  
```

### 10.如何实现一个双端队列？请简述双端队列的基本操作及其时间复杂度

**双端队列**（Double Ended Queue，简称 Deque）是一种允许从队列两端插入或删除元素的数据结构。双端队列可以在队列两端进行插入或删除操作，因此可以灵活地处理一些需要从队列两端进行操作的问题。

**双端队列的基本操作包括:**

**插入操作:** 向队列的头部或尾部插入一个元素，时间复杂度为 O(1)。

**删除操作:** 从队列的头部或尾部删除一个元素，时间复杂度为 O(1)。

**查找操作:** 获取队列的头部或尾部元素，时间复杂度为 O(1)。

**获取队列大小:** 获取队列中元素的个数，时间复杂度为 O(1)。