# 算法

## 1.数据结构线性表面试题

### 1.什么是线性表，java中有哪些线性表？

线性表是一种数据结构，由n个数据元素组成的有限序列，其中数据元素之间存在线性关系，即除了第一个和最后一个元素外，每个元素都有且只有一个直接前驱和直接后继。

在 Java 中，线性表是通过接口实现的。下面是 Java 中线性表相关的接口和类：

**List 接口**：代表了一个有序、可重复的序列，其中每个元素都有一个整数索引。它是 Collection 接口的子接口。

**ArrayList 类**：是 List 接口的一种实现，它使用数组来存储元素，支持快速随机访问元素。

**LinkedList 类**：也是 List 接口的一种实现，它使用链表来存储元素，支持快速在列表开头和结尾进行插入和删除操作。

**Vector 类**：与 ArrayList 类似，它也是 List 接口的一种实现，但是它是线程安全的。

**Stack 类**：代表了一个后进先出（LIFO）的栈，它继承自 Vector 类。

除此之外，Java 还提供了 Queue 接口和 Deque 接口，它们代表了队列和双端队列，也可以用来实现线性表。其中 LinkedList 类也可以用作队列和双端队列的实现。

### 2.线性表有哪些常见的存储方式？

线性表是一种常见的数据结构，常见的存储方式包括以下几种：

**数组存储**：将线性表中的元素依次存储在一段连续的内存空间中。数组的存取速度较快，但是插入和删除操作的时间复杂度较高。

**链式存储**：将线性表中的元素存储在不同的物理地址中，通过指针链接起来。链式存储的插入和删除操作较为灵活，但是访问元素时需要遍历链表，速度较慢。

**静态链表**：静态链表是利用数组模拟链表的存储结构，即使用数组来存储节点，通过数组下标来访问节点，使用指针来链接节点。静态链表的空间利用率高，但是容量固定，不能动态扩容。

**循环数组存储**：将线性表中的元素存储在一个循环数组中，通过下标访问元素。循环数组的存取速度较快，可以很方便地实现队列和栈等数据结构，但是插入和删除操作的时间复杂度较高。

**块状链表**：将线性表分成若干块，每块用链表存储。块状链表可以支持高效的块间操作，如合并、分裂等，但是实现较为复杂。

### 3.线性表的常见操作有哪些？

**插入操作**：在线性表中插入一个元素。

**删除操作**：从线性表中删除一个元素。

**查找操作**：在线性表中查找指定元素，并返回其位置或者值。

**修改操作**：修改线性表中指定位置的元素值。

**遍历操作**：依次访问线性表中的所有元素。

**合并操作**：将两个线性表合并成一个线性表。

**截取操作**：从线性表中截取出一个子表。

**排序操作**：将线性表中的元素按照一定的规则排序。

**清空操作**：清空线性表中的所有元素。

以上这些操作是线性表的基本操作，在实际应用中还会根据需要进行一些其他的操作。其中，插入、删除、查找、修改、遍历等操作是线性表中最常用的操作。

### 4.如何实现一个动态数组？请简述动态数组的特点和实现方法。

**1.** 创建一个DynamicArray类，该类包含三个成员变量：capacity（容量）、size（元素个数）和array（存储元素的数组）。

**2.** 定义构造函数，初始化容量为10，元素个数为0，数组长度为10。

**3.** 定义resize方法，用于扩容和缩容操作。当元素个数等于容量时，扩容为原来的两倍；当元素个数小于容量的一半时，缩容为原来的一半。

**4.** 定义add方法，用于向动态数组末尾添加元素。如果元素个数等于容量，先调用resize方法进行扩容。

**5.** 定义remove方法，用于从动态数组末尾删除元素并返回删除的元素。如果元素个数小于容量的一半，先调用resize方法进行缩容。

**6.** 使用泛型实现DynamicArray类，支持存储任意类型的元素。
编写测试代码，验证DynamicArray类的各个方法是否能够正常工作。

```java
    public class DynamicArray<E> {
        private int capacity;
        private int size;
        private Object[] array;

        public DynamicArray() {
            capacity = 10;
            size = 0;
            array = new Object[capacity];
        }

        public void resize(int newCapacity) {
            Object[] newArray = new Object[newCapacity];
            for (int i = 0; i < size; i++) {
                newArray[i] = array[i];
            }
            array = newArray;
            capacity = newCapacity;
        }

        public void add(E element) {
            if (size == capacity) {
                resize(2 * capacity);
            }
            array[size] = element;
            size++;
        }

        public E remove() {
            if (size == 0) {
                throw new RuntimeException("Array is empty.");
            }
            E element = (E) array[size - 1];
            size--;
            if (size < capacity / 2) {
                resize(capacity / 2);
            }
        return element;
        }
    }
```

### 5.如何判断一个链表中是否存在环？请给出相应的算法及其时间复杂度。

判断一个链表中是否存在环可以使用双指针法，也称为快慢指针法，具体算法如下：

**1.** 定义两个指针slow和fast，初始值均指向链表头部。

**2.** slow指针每次移动一个节点，fast指针每次移动两个节点，直到fast指针指向链表尾部，或者slow指针和fast指针相遇。

**3.** 如果fast指针指向链表尾部，说明链表中没有环；如果slow指针和fast指针相遇，说明链表中存在环。

相应的时间复杂度为O(n)，其中n为链表中节点的个数，因为快指针最多会遍历整个链表，而慢指针最多只会遍历一半链表，所以时间复杂度为线性。

```java
    public class ListNode {
        int val;
        ListNode next;
        ListNode(int x) {
            val = x;
            next = null;
        }
    }

    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }
        ListNode slow = head;
        ListNode fast = head.next;
        while (slow != fast) {
            if (fast == null || fast.next == null) {
                return false;
            }
            slow = slow.next;
            fast = fast.next.next;
        }
        return true;
    }
```

hasCycle方法实现了使用双指针法判断链表中是否存在环的功能。在方法中，首先判断链表是否为空或只有一个节点，如果是，则返回false。

然后定义慢指针和快指针，分别指向链表头部和头部的下一个节点。在while循环中，如果快指针指向null或者快指针的下一个节点指向null，则说明链表中不存在环，返回false；

否则，慢指针每次移动一个节点，快指针每次移动两个节点，直到两个指针相遇，说明链表中存在环，返回true。

### 6.如何实现一个循环队列？请简述循环队列的基本操作及其时间复杂度。

循环队列是一种常用的队列实现方式，它通过循环利用数组空间来实现队列的基本操作。循环队列中，队尾指针和队头指针都可以循环移动，可以高效地实现入队和出队操作。

循环队列的基本操作包括：

**1.初始化操作：** 创建一个空的循环队列，需要指定队列的最大容量。

**2.入队操作：** 将元素添加到队尾，如果队列已满则无法添加。

**3.出队操作：** 从队头删除元素并返回该元素，如果队列为空则无法删除。

**4.获取队列头部元素：** 获取队头元素，但不删除该元素，如果队列为空则返回null。

**5.判断队列是否为空：** 判断队列中是否有元素。

**6.判断队列是否已满：** 判断队列是否已满，如果队列已满则无法添加元素。

```java
    public class CircularQueue {
        private int[] queue;     // 存储队列元素的数组
        private int front;       // 队头指针
        private int rear;        // 队尾指针
        private int size;        // 队列元素个数
        private int capacity;    // 队列容量

        // 初始化队列
        public CircularQueue(int k) {
            capacity = k;
            queue = new int[capacity];
            front = 0;
            rear = 0;
            size = 0;
        }

        // 入队操作
        public boolean enqueue(int value) {
            if (isFull()) {
                return false;
            }
            queue[rear] = value;
            rear = (rear + 1) % capacity;   // rear指针循环移动
            size++;
            return true;
        }

        // 出队操作
        public int dequeue() {
            if (isEmpty()) {
                return -1;
            }
            int value = queue[front];
            front = (front + 1) % capacity;  // front指针循环移动
            size--;
            return value;
        }

        // 获取队头元素
        public int getFront() {
            if (isEmpty()) {
                return -1;
            }
            return queue[front];
        }

        // 判断队列是否为空
        public boolean isEmpty() {
            return size == 0;
        }

        // 判断队列是否已满
        public boolean isFull() {
            return size == capacity;
        }
    }
```

### 7.如何实现一个哈希表？请简述哈希表的实现原理和冲突解决方法。

哈希表是一种常用的数据结构，用于快速查找和插入数据。它的核心思想是将每个元素的关键字映射到一个唯一的位置上，这个位置就是哈希值。

哈希表通过哈希函数将元素的关键字转化为哈希值，并将其存储在数组中对应的位置上。当需要查找或插入一个元素时，哈希表使用相同的哈希函数将关键字转化为哈希值，并在数组中查找对应的位置，这样可以快速定位到元素的位置，提高了查找和插入的效率。

**哈希表的实现原理**：

**哈希函数**：哈希函数是将元素的关键字转化为哈希值的算法，它应该满足以下条件：

**a**. 输出的哈希值是一个非负整数。

**b**. 输入相同的关键字应该得到相同的哈希值。

**c**. 输入不同的关键字应该得到不同的哈希值。

**数组**：哈希表通过数组来存储元素。数组的大小应该足够大，以容纳所有可能的元素。

**冲突处理**：由于哈希函数可能会将不同的关键字映射到同一个位置上，所以在插入元素时可能会出现冲突。哈希表通过不同的冲突解决方法来处理冲突。

**哈希表的冲突解决方法**：

**开放地址法**：在出现冲突时，通过寻找其他空闲的位置来解决冲突。常用的开放地址法有线性探测法、二次探测法和双重哈希法。

**链地址法**：在出现冲突时，将冲突的元素存储在同一个位置上，并用链表来解决冲突。链地址法是最常用的冲突解决方法。

**其他方法**：还有其他的冲突解决方法，如建立公共溢出区、再哈希法等，但不如前两种方法常用。

**实现哈希表的步骤**：

**1.** 定义哈希表的数据结构：包括数组、哈希函数等。

**2.** 实现哈希函数：根据具体的需求选择合适的哈希函数，将元素的关键字转化为哈希值。

**3.** 实现插入、删除和查找操作：根据不同的冲突解决方法，实现相应的操作。在插入时，需要先计算出元素的哈希值，然后根据冲突解决方法来确定插入的位置。在查找和删除时，也需要计算出元素

**链地址法实现的哈希表**

```java
    class Node {
        int key;
        String value;
        Node next;

        public Node(int key, String value) {
            this.key = key;
            this.value = value;
            this.next = null;
        }
    }

    class MyHashMap {
        private static final int SIZE = 1000;
        private Node[] table;

        public MyHashMap() {
            table = new Node[SIZE];
        }

        public void put(int key, String value) {
            int index = hash(key);
            Node node = table[index];

             while (node != null) {
                if (node.key == key) {
                    node.value = value;
                    return;
                }
                node = node.next;
            }

            Node newNode = new Node(key, value);
            newNode.next = table[index];
            table[index] = newNode;
        }

        public String get(int key) {
            int index = hash(key);
            Node node = table[index];

            while (node != null) {
                 if (node.key == key) {
                    return node.value;
                }
                node = node.next;
            }

            return null;
        }

        public void remove(int key) {
            int index = hash(key);
            Node node = table[index];
            Node prev = null;
    
            while (node != null) {
                if (node.key == key) {
                    if (prev == null) {
                        table[index] = node.next;
                    } else {
                        prev.next = node.next;
                    }
                    return;
                }
                prev = node;
                node = node.next;
            }    
        }

        private int hash(int key) {
            return key % SIZE;
        }
    }
```

在这个实现中，使用了链表来解决冲突。每个节点包括一个键值对和一个指向下一个节点的指针。

哈希表使用一个固定大小的数组来存储链表头节点。

在插入时，根据键的哈希值计算出数组下标，然后在相应的链表中查找是否已经存在相同的键，如果存在则更新其值，否则将新节点插入到链表的头部。

在查找和删除时也是类似的流程。

### 8.如何实现一个堆？请简述堆的基本操作及其时间复杂度。

> 堆（Heap）是一种基于完全二叉树的数据结构，其中每个节点的值都不大于
> （或不小于）其子节点的值，被称为最大堆（Max Heap）或最小堆（Min Heap）。

**堆的基本操作包括**：

**插入操作**：将一个元素插入到堆中，需要保证插入后仍然满足堆的性质。

**删除操作**：删除堆中的最大元素（最小元素），需要保证删除后仍然满足堆的性质。

**查找操作**：查找堆中的最大元素（最小元素），时间复杂度为 O(1)。

**堆的时间复杂度如下**：

**插入操作:** 时间复杂度为 O(log n)，其中 n 是堆中元素的个数。

**删除操作:** 时间复杂度为 O(log n)，其中 n 是堆中元素的个数。

**查找操作:** 时间复杂度为 O(1)。

```java
    class MaxHeap {
        private int[] heap;
        private int size;
        private int capacity;

        public MaxHeap(int capacity) {
            heap = new int[capacity];
            size = 0;
            this.capacity = capacity;
        }

        public void insert(int x) {
            if (size == capacity) {
                return;
            }

            heap[size] = x;
            size++;

            int i = size - 1;
            while (i > 0 && heap[i] > heap[(i - 1) / 2]) {
                swap(i, (i - 1) / 2);
                i = (i - 1) / 2;
            }
        }

        public int removeMax() {
            if (size == 0) {
                return -1;
            }

            int max = heap[0];
            size--;

            heap[0] = heap[size];
            heap[size] = 0;

            int i = 0;
            while (true) {
                int left = i * 2 + 1;
                int right = i * 2 + 2;
                int largest = i;

                if (left < size && heap[left] > heap[largest]) {
                    largest = left;
                }

                if (right < size && heap[right] > heap[largest]) {
                    largest = right;
                }

                if (largest != i) {
                    swap(i, largest);
                    i = largest;
                } else {
                    break;
                }
            }

            return max;
        }    

        private void swap(int i, int j) {
            int temp = heap[i];
            heap[i] = heap[j];
            heap[j] = temp;
        }
    }
```

### 9.如何实现一个优先队列？请简述优先队列的实现方法及其时间复杂度。

优先队列是一种能够维护元素优先级的数据结构，每次从队列中取出的元素都是优先级最高（或最低）的元素。常见的实现方法包括堆、二叉搜索树等。

其中，基于堆实现的优先队列被称为堆（Heap）优先队列，也是最常见的实现方式。堆优先队列可以通过最大堆（Max Heap）或最小堆（Min Heap）来实现。

**堆优先队列的基本操作包括：**

**插入操作:** 将一个元素插入到队列中，需要保证插入后仍然满足堆的性质。

**删除操作:** 删除队列中的最大元素（最小元素），需要保证删除后仍然满足堆的性质。

**查找操作:** 查找队列中的最大元素（最小元素），时间复杂度为 O(1)。

堆优先队列的时间复杂度如下：

**插入操作:** 时间复杂度为 O(log n)，其中 n 是队列中元素的个数。

**删除操作:** 时间复杂度为 O(log n)，其中 n 是队列中元素的个数。

**查找操作:** 时间复杂度为 O(1)。

下面是一个简单的使用 Java 中的 PriorityQueue 类实现堆优先队列的示例代码：

```java
    import java.util.PriorityQueue;

    public class PriorityQueueExample {
        public static void main(String[] args) {
            PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);

            pq.offer(3);
            pq.offer(1);
            pq.offer(4);
            pq.offer(2);
    
            while (!pq.isEmpty()) {
                System.out.println(pq.poll());
            }
        }
    }  
  
```

### 10.如何实现一个双端队列？请简述双端队列的基本操作及其时间复杂度

**双端队列**（Double Ended Queue，简称 Deque）是一种允许从队列两端插入或删除元素的数据结构。双端队列可以在队列两端进行插入或删除操作，因此可以灵活地处理一些需要从队列两端进行操作的问题。

**双端队列的基本操作包括:**

**插入操作:** 向队列的头部或尾部插入一个元素，时间复杂度为 O(1)。

**删除操作:** 从队列的头部或尾部删除一个元素，时间复杂度为 O(1)。

**查找操作:** 获取队列的头部或尾部元素，时间复杂度为 O(1)。

**获取队列大小:** 获取队列中元素的个数，时间复杂度为 O(1)。





## 2.数据结构树结构面试题

### 1.有哪些常见的树结构，分别有什么特点

**二叉树（Binary Tree）**：每个节点最多有两个子节点。二叉树可以分为满二叉树、完全二叉树、二叉搜索树等。

**二叉搜索树（Binary Search Tree）**：左子树上所有节点的值均小于根节点的值，右子树上所有节点的值均大于根节点的值。可以支持插入、删除、查找操作，并且时间复杂度均为O(log n)。

**平衡二叉树（Balanced Binary Tree）**：一种特殊的二叉搜索树，其左右子树的高度差不超过1。平衡二叉树可以提高查找操作的效率。

**B树（B-Tree）**：多路平衡查找树，每个节点可以有多个子节点。B树通常用于磁盘或其他外部存储器上的数据结构，因为它可以减少I/O操作次数。

**红黑树（Red-Black Tree）**：一种特殊的自平衡二叉搜索树，其任意节点到其每个叶子节点的路径包含相同数量的黑色节点。红黑树可以保证每个操作的最坏情况下时间复杂度为O(log n)。

**堆（Heap）**：一种特殊的树形数据结构，分为最大堆和最小堆。最大堆中，每个节点的值都大于或等于其子节点的值；最小堆中，每个节点的值都小于或等于其子节点的值。堆通常用于实现优先队列。

### 2.如何在一棵二叉搜索树中查找指定值的节点？

递归实现：

**1.** 如果根节点为空，则返回空。

**2.** 如果目标值等于根节点的值，则返回根节点。

**3.** 如果目标值小于根节点的值，则在左子树中查找。

**4.** 如果目标值大于根节点的值，则在右子树中查找。

```java
    public class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode(int x) { val = x; }
    }

    public TreeNode searchBST(TreeNode root, int val) {
        if (root == null || root.val == val) {
            return root;
        }
        if (val < root.val) {
            return searchBST(root.left, val);
        } else {
            return searchBST(root.right, val);
        }
    }
```

其中，TreeNode 是树节点的定义，searchBST 方法用于在二叉搜索树中查找指定值的节点。

如果根节点为空或者根节点的值等于目标值，则返回根节点。

如果目标值小于根节点的值，则在左子树中查找；否则在右子树中查找。

最终返回找到的节点或者 null。

### 3.为什么需要平衡二叉树？如何实现平衡二叉树？

在二叉搜索树中，如果插入的节点有序，则会导致树的高度较大，查询、插入、删除操作的时间复杂度会变得很高，因为这些操作的时间复杂度与树的高度相关。为了降低树的高度，就需要将树保持平衡，使得树的高度尽可能小。平衡二叉树是一种能够自动保持平衡的二叉搜索树。

**如何实现平衡二叉树**？

平衡二叉树的实现有很多种，其中 AVL 树和红黑树是比较常见的实现方式。

**AVL 树:** 是一种自平衡的二叉搜索树，它的特点是：每个节点的左右子树高度差的绝对值不超过 1。当插入或删除一个节点时，AVL 树会通过旋转操作来保持平衡。

**红黑树:** 是一种自平衡的二叉搜索树，它的特点是：每个节点是红色或黑色，根节点是黑色，每个叶子节点是黑色的空节点（NIL 节点），不能有连续的两个红色节点。红黑树的插入和删除操作也会通过旋转和颜色变换来保持平衡。

在实际应用中，红黑树的实现相对简单，性能也比 AVL 树更优秀，因此红黑树被广泛应用于计算机科学领域。

```java
    public class AVLTree {
        private class Node {
            int val, height;
            Node left, right;
            public Node(int val) {
                this.val = val;
                this.height = 1;
            }
        }
    
        private Node root;

        // 左旋操作
        private Node leftRotate(Node node) {
            Node rightChild = node.right;
            Node leftGrandChild = rightChild.left;
            rightChild.left = node;
            node.right = leftGrandChild;
            node.height = Math.max(getHeight(node.left), getHeight(node.right)) + 1;
            rightChild.height = Math.max(getHeight(rightChild.left), getHeight(rightChild.right)) + 1;
            return rightChild;
        }

        // 右旋操作
        private Node rightRotate(Node node) {
            Node leftChild = node.left;
            Node rightGrandChild = leftChild.right;
            leftChild.right = node;
            node.left = rightGrandChild;
            node.height = Math.max(getHeight(node.left), getHeight(node.right)) + 1;
            leftChild.height = Math.max(getHeight(leftChild.left), getHeight(leftChild.right)) + 1;
            return leftChild;
        }

        // 获取节点高度
        private int getHeight(Node node) {
            return node == null ? 0 : node.height;
        }

        // 获取节点平衡因子
        private int getBalanceFactor(Node node) {
            return node == null ? 0 : getHeight(node.left) - getHeight(node.right);
        }

        // 插入操作
        public void insert(int val) {
            root = insertNode(root, val);
        }

        private Node insertNode(Node node, int val) {
            if (node == null) {
                return new Node(val);
            }
            if (val < node.val) {
                node.left = insertNode(node.left, val);
            } else if (val > node.val) {
                node.right = insertNode(node.right, val);
            } else {
                return node;
            }
            // 更新节点高度
            node.height = Math.max(getHeight(node.left), getHeight(node.right)) + 1;
            // 计算平衡因子
            int balanceFactor = getBalanceFactor(node);
            if (balanceFactor > 1 && val < node.left.val) {
                // LL情况，右旋操作
                return rightRotate(node);
            }
            if (balanceFactor < -1 && val > node.right.val) {
                // RR情况，左旋操作
                return leftRotate(node);
            }
            if (balanceFactor > 1 && val > node.left.val) {
                // LR情况，先左旋再右旋操作
                node.left = leftRotate(node.left);
                return rightRotate(node);
            }
            if (balanceFactor < -1 && val < node.right.val) {
                // RL情况，先右旋再左旋操作
                node.right = rightRotate(node.right);
                return leftRotate(node);
            }    
            return node;
        }
    }
```

### 4.如何在一棵红黑树中插入一个节点？

以普通的二叉搜索树的方式将新节点插入到树中。

将新插入的节点标记为红色。

根据红黑树的规则进行修复，使树重新成为红黑树。

```java
    // 定义红黑树节点颜色，RED为红色，BLACK为黑色
    enum Color {
        RED,
        BLACK
    }

    // 定义红黑树节点类
    class Node {
        int val;         // 节点值
        Node left;       // 左子节点
        Node right;      // 右子节点
        Node parent;     // 父节点
        Color color;     // 节点颜色

        // 构造函数
        public Node(int val) {
            this.val = val;
            this.color = Color.RED;  // 默认新插入节点为红色
        }
    }

    // 定义红黑树类
    class RedBlackTree {
        private Node root;   // 根节点
    
        // 构造函数
        public RedBlackTree() {
            this.root = null;
        }

        // 插入节点
        public void insert(int val) {
            Node newNode = new Node(val);  // 新建待插入节点
            if (root == null) {   // 如果根节点为空，将待插入节点设为根节点，颜色为黑色
                root = newNode;
                newNode.color = Color.BLACK;
            } else {
                Node current = root;   // 定义当前节点
                Node parent = null;    // 定义当前节点的父节点
                while (true) {
                    parent = current;
                    if (val < current.val) {  // 如果待插入值小于当前节点值，向左子树查找
                        current = current.left;
                        if (current == null) {   // 如果左子节点为空，将待插入节点设为左子节点
                            parent.left = newNode;
                            newNode.color = Color.RED;   // 新节点默认为红色
                            newNode = parent.left;
                            break;
                        }
                    } else {  // 如果待插入值大于或等于当前节点值，向右子树查找
                        current = current.right;
                        if (current == null) {  // 如果右子节点为空，将待插入节点设为右子节点
                            parent.right = newNode;
                            newNode.color = Color.RED;  // 新节点默认为红色
                            newNode = parent.right;
                            break;
                            }
                    }
                }
                // 调整红黑树的平衡
                fixUp(newNode);
            }
        }

        // 调整红黑树的平衡
        // 调整红黑树的平衡
        private void fixUp(Node newNode) {
            while (newNode != root && newNode.color == Color.RED && newNode.parent.color == Color.RED) {
                // 如果当前节点的父节点是祖父节点的左子节点
                if (newNode.parent == newNode.parent.parent.left) {
                    Node uncle = newNode.parent.parent.right;   // 定义叔节点
                    // 如果叔节点是红色，将当前节点、父节点、叔节点都设为黑色，祖父节点设为红色，然后将当前节点移动到祖父节点
                    if (uncle != null && uncle.color == Color.RED) {
                        uncle.color = Color.BLACK;
                        newNode.parent.color = Color.BLACK;
                        newNode.parent.parent.color = Color.RED;
                        newNode = newNode.parent.parent;
                    } else {  // 如果叔节点是黑色
                        // 如果当前节点是父节点的右子节点，先将当前节点设为父节点，然后左旋
                        if (newNode == newNode.parent.right) {
                            newNode = newNode.parent;
                            leftRotate(newNode);
                        }
                        // 将父节点设为黑色，祖父节点设为红色，然后右旋
                        newNode.parent.color = Color.BLACK;
                        newNode.parent.parent.color = Color.RED;
                        rightRotate(newNode.parent.parent);
                    }
                } else {  // 如果当前节点的父节点是祖父节点的右子节点
                    Node uncle = newNode.parent.parent.left;   // 定义叔节点
                    // 如果叔节点是红色，将当前节点、父节点、叔节点都设为黑色，祖父节点设为红色，然后将当前节点移动到祖父节点
                    if (uncle != null && uncle.color == Color.RED) {
                        uncle.color = Color.BLACK;
                        newNode.parent.color = Color.BLACK;
                        newNode.parent.parent.color = Color.RED;
                        newNode = newNode.parent.parent;
                    } else {  // 如果叔节点是黑色
                        // 如果当前节点是父节点的左子节点，先将当前节点设为父节点，然后右旋
                        if (newNode == newNode.parent.left) {
                            newNode = newNode.parent;
                            rightRotate(newNode);
                        }
                        // 将父节点设为黑色，祖父节点设为红色，然后左旋
                        newNode.parent.color = Color.BLACK;
                        newNode.parent.parent.color = Color.RED;
                        leftRotate(newNode.parent.parent);
                    }
                }
            }
            root.color = Color.BLACK;  // 根节点始终为黑色
        }

        // 左旋操作
        private void leftRotate(Node x) {
            Node y = x.right;
            x.right = y.left;
            if (y.left != null) {
                y.left.parent = x;
            }
            y.parent = x.parent;
            if (x.parent == null) {
                root = y;
            } else if (x == x.parent.left) {
                x.parent.left = y;
            } else {
                x.parent.right = y;
            }
            y.left = x;
            x.parent = y;
        }

        // 右旋操作
        private void rightRotate(Node x) {
            Node y = x.left;
            x.left = y.right;
            if (y.right != null) {
                y.right.parent = x;
            }
            y.parent = x.parent;
            if (x.parent == null) {
                root = y;
            } else if (x == x.parent.right) {
                x.parent.right = y;
            } else {
                x.parent.left = y;
            }
            y.right = x;
            x.parent = y;
        }
    }
```

### 5.如何找到一棵二叉树中的最大路径和？

在一棵二叉树中找到最大路径和可以通过递归实现。对于当前节点，最大路径和可能有三种情况：

最大路径和为当前节点的值加上左子树中的最大路径和，右子树中的最大路径和；

最大路径和为当前节点的值加上左子树中的最大路径和；

最大路径和为当前节点的值加上右子树中的最大路径和。

对于每个节点，我们需要计算这三种情况下的最大路径和，并将它们与当前最大路径和比较。

同时，我们需要返回当前节点值加上左子树和右子树中的最大路径和的和，作为向上递归时的结果。

```java
    class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        
        public TreeNode(int val) {
            this.val = val;
        }
    }

    class Solution {
        private int maxPathSum = Integer.MIN_VALUE;

        public int maxPathSum(TreeNode root) {
            maxPathSumHelper(root);
            return maxPathSum;
        }    

        private int maxPathSumHelper(TreeNode node) {
            if (node == null) {
                return 0;
            }

            int leftMaxPathSum = maxPathSumHelper(node.left);
            int rightMaxPathSum = maxPathSumHelper(node.right);

            int maxPathSumWithNode = Math.max(node.val, Math.max(node.val + leftMaxPathSum, node.val + rightMaxPathSum));
            int maxPathSumWithNodeAndChildren = Math.max(maxPathSumWithNode, node.val + leftMaxPathSum + rightMaxPathSum);
            maxPathSum = Math.max(maxPathSum, maxPathSumWithNodeAndChildren);

            return maxPathSumWithNode;
        }
    }
```

### 6.如何将一棵二叉树展开成一个链表？

将一棵二叉树展开成一个链表，可以按照如下步骤进行操作：

1.对于根节点，首先将其左子树展开成一个链表，并将其右子树展开成一个链表。

2.如果左子树展开成了链表，将其链接到根节点的右子树上。

3.如果右子树展开成了链表，将其链接到左子树展开成链表的末尾。

4.如果左右子树都已经展开成了链表，则不需要进行任何操作。

```
    class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode(int x) { val = x; }
    }

    class Solution {
        public void flatten(TreeNode root) {
            if (root == null) {
                return;
            }
            flatten(root.left);
            flatten(root.right);
            if (root.left != null) {
                TreeNode node = root.left;
                while (node.right != null) {
                    node = node.right;
                }
                node.right = root.right;
                root.right = root.left;
                root.left = null;
            }
        }
    }
```

### 7.如何判断一棵二叉树是否为二叉平衡树？

> 二叉平衡树（Balanced Binary Tree），也称为 AVL 树，是一种自平衡的二叉搜索树。它的左右子树的高度差不能超过1。

判断一棵二叉树是否为二叉平衡树，可以采用递归的方式。

对于每个节点，先判断其左右子树是否为平衡树，如果是，则计算左右子树的高度差，如果高度差不超过1，则返回当前节点所在子树的高度；

如果高度差超过1，则返回一个标记值表示当前子树不是平衡树。

具体实现可以定义一个函数，用于判断当前子树是否为平衡树，并返回当前子树的高度，如果不是平衡树，则返回一个标记值-1。

```java
    class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode(int x) { val = x; }
    }

    class Solution {
        public boolean isBalanced(TreeNode root) {
            return getHeight(root) != -1;
        }

        private int getHeight(TreeNode node) {
            if (node == null) {
               return 0;
            }
            int leftHeight = getHeight(node.left);
            if (leftHeight == -1) {
                return -1;
            }
            int rightHeight = getHeight(node.right);
            if (rightHeight == -1) {
                return -1;
            }
            if (Math.abs(leftHeight - rightHeight) > 1) {
                return -1;
            }
            return Math.max(leftHeight, rightHeight) + 1;
        }
    }
```

在该代码中，isBalanced() 函数调用 getHeight() 函数获取当前节点所在子树的高度，并判断当前子树是否为平衡树。

getHeight() 函数采用递归的方式计算当前子树的高度，如果左右子树高度差超过1，则返回-1表示当前子树不是平衡树，否则返回当前子树的高度。

如果左右子树都是平衡树，并且高度差不超过1，则返回当前子树的高度。

### 8.如何找到一棵二叉树中的最近公共祖先节点，假设每个节点都有一个指向父节点的指针？

假设每个节点都有一个指向父节点的指针，可以使用如下算法来找到二叉树中任意两个节点的最近公共祖先节点。

1.首先分别求出两个节点的深度（即从根节点到该节点的路径长度）。

2.让深度较深的节点向上移动，直到两个节点位于同一深度。

3.然后同时向上移动两个节点，直到找到它们的最近公共祖先节点。

```java
    package com.wwdz.home.api.service;

    // 定义二叉树节点类
    class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode parent;

        public TreeNode(int val) {
            this.val = val;
            this.left = null;
            this.right = null;
            this.parent = null;
        }
        public TreeNode lowestCommonAncestor(TreeNode p, TreeNode q) {
            // 分别求出两个节点的深度
            int depthP = getDepth(p);
            int depthQ = getDepth(q);

            // 将深度较深的节点向上移动，直到两个节点位于同一深度
            while (depthP > depthQ) {
                p = p.parent;
                depthP--;
            }
            while (depthQ > depthP) {
                q = q.parent;
                depthQ--;
            }

            // 同时向上移动两个节点，直到找到它们的最近公共祖先节点
            while (p != q) {
                p = p.parent;
                q = q.parent;
            }

            return p;
        }

        // 求出节点的深度
        private int getDepth(TreeNode node) {
            int depth = 0;
            while (node.parent != null) {
                depth++;
                node = node.parent;
            }
            return depth;
        }
    }
```

该算法的时间复杂度为 �(ℎ)*O*(*h*)，其中 ℎ*h* 是二叉树的高度。

### 9.如何在一棵二叉树中找到从根节点到叶节点的所有路径？

可以使用深度优先搜索（DFS）算法遍历二叉树，并记录下每一条从根节点到叶节点的路径。具体做法如下：

1.定义一个列表或数组 path 用于记录从根节点到当前节点的路径。

2.从根节点开始遍历二叉树，对于每个节点：

- 将当前节点加入 path 中。

- 如果当前节点是叶节点，将 path 添加到结果列表中。

- 否则，递归遍历当前节点的左右子节点。

- 遍历完成后，将 path 中的当前节点移除。

```java
    class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode(int x) { val = x; }
    }

    class Solution {
        public List<List<Integer>> allPaths(TreeNode root) {
            List<List<Integer>> res = new ArrayList<>();
            List<Integer> path = new ArrayList<>();
            dfs(root, path, res);
            return res;
        }

    vprivate void dfs(TreeNode node, List<Integer> path, List<List<Integer>> res) {
            if (node == null) {
                 return;
            }
            path.add(node.val);
            if (node.left == null && node.right == null) {
                res.add(new ArrayList<>(path)); // 添加当前路径到结果列表
            } else {
                dfs(node.left, path, res); // 递归遍历左子树
                dfs(node.right, path, res); // 递归遍历右子树
            }    
            path.remove(path.size() - 1); // 移除当前节点
        }
    }
```

1.dfs 方法是核心函数，它接受三个参数：node 表示当前节点，path 表示从根节点到当前节点的路径，res 表示所有从根节点到叶节点的路径的列表。

2.将当前节点加入 path 中，表示当前节点是路径上的一个节点，即将当前节点加入到已有路径的末尾。

3.判断当前节点是否为叶节点，如果是，则将 path 添加到结果列表 res 中。叶节点是指没有左右子节点的节点。

4.如果当前节点不是叶节点，则递归遍历当前节点的左右子节点。分别将左右子节点作为当前节点，更新 path，继续递归。这里使用深度优先搜索算法。

5.遍历完成后，将 path 中的当前节点移除，这是因为在递归过程中，path 列表是共享的，如果不移除当前节点，会影响到其它路径的遍历。

6.最后将 res 列表作为函数的返回值。

### 10.如何在一棵二叉树中找到节点值最小的节点？

可以使用深度优先搜索（DFS）或广度优先搜索（BFS）的方法遍历整棵二叉树，同时记录遍历过程中找到的节点值最小的节点。

```java
    class TreeNode {
         int val;
        TreeNode left;
        TreeNode right;
        TreeNode(int x) { val = x; }
    }

    class Solution {
        public int findMin(TreeNode root) {
            if (root == null) { // 如果树为空，返回 0
                return 0;
            }
            while (root.left != null) { // 当左子节点不为空时，一直往左子树遍历
                root = root.left;
            }
            return root.val; // 最后返回最左下角的节点值
        }
    }
```

- 此代码假设二叉树中没有负数节点。如果存在负数节点，则最小节点的值可能为负数。

### 11.如何在一棵二叉树中找到第K小的节点？

要在一棵二叉树中找到第K小的节点，可以利用中序遍历的特点。

中序遍历得到的节点值是从小到大排序的，因此可以中序遍历二叉树，并记录已经遍历过的节点个数，当遍历到第K个节点时，即为第K小的节点。

```java
    /**
     * Definition for a binary tree node.
     * public class TreeNode {
     *     int val;
     *     TreeNode left;
     *     TreeNode right;
     *     TreeNode(int x) { val = x; }
     * }
     */
    class Solution {
        public int kthSmallest(TreeNode root, int k) {
            // 记录已经遍历过的节点个数
            int count = 0;
            // 栈用于辅助中序遍历
            Stack<TreeNode> stack = new Stack<>();
            // 当前节点
            TreeNode curr = root;

            while (curr != null || !stack.isEmpty()) {
                // 先将当前节点及其左子节点全部入栈
                while (curr != null) {
                    stack.push(curr);
                    curr = curr.left;
                }

                // 取出栈顶节点并记录已经遍历过的节点个数
                curr = stack.pop();
                count++;

                // 当已经遍历到第k个节点时，返回该节点的值
                if (count == k) {
                    return curr.val;
                }

                // 遍历右子树
                curr = curr.right;
            }

            return -1; // 不存在第K小的节点，返回-1
        }
    }
```

在上述代码中，使用了栈来辅助中序遍历二叉树，首先将当前节点及其左子节点全部入栈，

然后取出栈顶节点并记录已经遍历过的节点个数，当已经遍历到第K个节点时，返回该节点的值。如果不存在第K小的节点，返回-1。





## 3.数据结构图结构面试题

```
 图结构是一种用于表示对象之间关系的数据结构。
 图结构由节点和边组成，节点表示对象，边表示对象之间的关系。
 在图结构中，节点也被称为顶点，边也被称为连接。
```



### 1.常见的图结构有哪些

**无向图（Undirected Graph）**：在无向图中，每个节点可以连接到其他节点，连接是双向的。

**有向图（Directed Graph）**：在有向图中，每个节点可以连接到其他节点，连接是单向的。

**带权图（Weighted Graph）**：在带权图中，每个边缘或连接都有一个与之相关的权重或成本。

**无向带权图（Undirected Weighted Graph）**：在无向带权图中，每个边缘或连接都有一个与之相关的权重或成本，并且连接是双向的。

**有向带权图（Directed Weighted Graph）**：在有向带权图中，每个边缘或连接都有一个与之相关的权重或成本，并且连接是单向的。

### 2.什么是图的连通性？

图的连通性是指在一个无向图中，如果任意两个节点都有一条路径相连，那么该图就是连通的。

也就是说，如果对于图中的任意两个节点，存在一条路径将它们相连，则这个图是连通的。

一个无向图可以有多个连通分量，每个连通分量都是一个最大连通子图。

在一个有向图中，如果每个节点都可以通过一些有向路径到达任意其他节点，那么该有向图就是强连通的。

如果一个有向图不是强连通的，那么它可以被划分为多个强连通分量，每个强连通分量都是该有向图的最大强连通子图。

图的连通性是图结构中非常重要的概念，因为它关系到许多图算法的正确性和性能。

例如，在一个连通的无向图中，深度优先搜索算法可以遍历所有节点。而在一个有向图中，如果不是强连通的，则某些节点可能永远无法访问到。

### 3.如何判断一个无向图是一棵树？

1.这个无向图是连通的。

2.这个无向图没有环。

“连通的”意味着无论从哪个点开始，都可以通过边相连的方式到达这个无向图的所有点；

“没有环”则意味着在这个无向图中不存在任何形式的回路，也就是说，不存在任何一条边可以让你从一个点出发走到某个点再回到原点。

因此，判断一个无向图是否为一棵树，可以使用深度优先搜索（DFS）或广度优先搜索（BFS）等算法，对图进行遍历，并检查是否满足上述两个条件。

如果满足，那么这个无向图就是一棵树。否则，这个无向图就不是一棵树。

```java
    import java.util.*;

    class UndirectedGraph {
        private int V; // 存储顶点数
        private LinkedList<Integer>[] adj; // 存储邻接表

        // 构造函数
        public UndirectedGraph(int v) {
            V = v;
            adj = new LinkedList[V];
            for (int i = 0; i < V; i++) {
                adj[i] = new LinkedList<Integer>();
            }
        }

        // 添加边
        public void addEdge(int v, int w) {
            adj[v].add(w);
            adj[w].add(v);
        }

        // DFS遍历判断
        public boolean isTree() {
            boolean[] visited = new boolean[V];
            if (isCyclic(0, visited, -1)) {
                return false;
            }
            // 检查是否联通
            for (int i = 0; i < V; i++) {
                if (!visited[i]) {
                    return false;
                }
            }
            return true;
        }

        // 判断是否有环
        private boolean isCyclic(int v, boolean[] visited, int parent) {
            visited[v] = true;
            // 遍历该节点的所有邻居节点
            for (int i : adj[v]) {
                // 如果邻居节点未被访问，则递归遍历
                if (!visited[i]) {
                    if (isCyclic(i, visited, v)) {
                        return true;
                    }
                    // 如果邻居节点已被访问，且不是当前节点的父节点，则说明存在环
                } else if (i != parent) {
                    return true;
                }
            }
            return false;
        }

        public static void main(String[] args) {
            // 创建一个无向图
            UndirectedGraph g = new UndirectedGraph(5);

            // 添加边
            g.addEdge(1, 0);
            g.addEdge(0, 2);
            g.addEdge(2, 1);
            g.addEdge(0, 3);
            g.addEdge(3, 4);

            // 判断是否为树
            if (g.isTree()) {
                System.out.println("是一棵树");
            } else {
                System.out.println("不是一棵树");
            }
        }
    }
```

这段代码实现了一个UndirectedGraph类，包含以下方法：

**addEdge(int v, int w)**：添加无向图中的一条边。

**isTree()**：判断该无向图是否为一棵树。

**isCyclic(int v, boolean[] visited, int parent)**：判断无向图中以节点v为起点的子图是否有环。

**main()**：创建一个无向图，并判断其是否为一棵树。

### 4.如何寻找有向无环图中的最长路径？

1.对有向无环图进行拓扑排序，得到一个拓扑序列。

2.对每个顶点，记录到达该顶点的最长路径。对于起点，其到达自己的最长路径为0，到达其他顶点的最长路径为负无穷。

3.遍历拓扑序列，对于每个顶点v和其所有出边(v, w)，更新所有到达顶点w的最长路径。更新方式为：将v的最长路径加上边(v, w)的权值，与w的当前最长路径进行比较，如果大于w的当前最长路径，则更新w的最长路径为该值。

4.遍历完拓扑序列后，所有顶点的最长路径都已经计算完成。最终的结果即为所有顶点中最长路径的最大值。

```java
    import java.util.*;

    class DAG {
        private int V; // 存储顶点数
        private List<List<Edge>> adj; // 存储邻接表

        // 存储有向边的类
        private class Edge {
            int to; // 边的终点
            int weight; // 边的权值
            Edge(int to, int weight) {
                this.to = to;
                this.weight = weight;
            }
        }
    
        // 构造函数
        public DAG(int v) {
            V = v;
            adj = new ArrayList<List<Edge>>(V);
            for (int i = 0; i < V; i++) {
                adj.add(new ArrayList<Edge>());
            }
        }

        // 添加边
        public void addEdge(int from, int to, int weight) {
            Edge e = new Edge(to, weight);
            adj.get(from).add(e);
        }

        // 寻找最长路径
        public int longestPath(int start, int end) {
            int[] dist = new int[V];
            Arrays.fill(dist, Integer.MIN_VALUE);
            dist[start] = 0;

            // 拓扑排序
            List<Integer> topoOrder = topologicalSort();

            // 更新最长路径
            for (int i = 0; i < topoOrder.size(); i++) {
                int u = topoOrder.get(i);
                if (u == end) {
                    break; // 如果已经到达终点，提前结束
                }
                if (dist[u] == Integer.MIN_VALUE) {
                    continue; // 如果u无法到达起点，跳过
                }
               for (Edge e : adj.get(u)) {
                    int v = e.to;
                    int weight = e.weight;
                    dist[v] = Math.max(dist[v], dist[u] + weight);
                }
            }

            return dist[end];
        }

        // 拓扑排序
        private List<Integer> topologicalSort() {
            List<Integer> order = new ArrayList<Integer>();
            int[] inDegree = new int[V];
            for (int i = 0; i < V; i++) {
                for (Edge e : adj.get(i)) {
                    int j = e.to;
                    inDegree[j]++;
                }
            }
            Queue<Integer> q = new LinkedList<Integer>();
            for (int i = 0; i < V; i++) {
                if (inDegree[i] == 0) {
                    q.offer(i);
                }
            }
            while (!q.isEmpty()) {
                int i = q.poll();
                order.add(i);
                for (Edge e : adj.get(i)) {
                    int j = e.to;
                    inDegree[j]--;
                    if (inDegree[j] == 0) {
                        q.offer(j);
                    }
                }
            }
            return order;
        }
    }    
```

### 5.如何实现一个图的深度优先遍历？

```java
深度优先遍历（Depth First Traversal）是一种图遍历算法，其核心思想是从起点开始，不断沿着一条路径走到底，
直到不能继续为止，然后返回到最近的还有未探索的分支的节点继续探索，直到遍历完所有的节点。
    import java.util.*;

    class Graph {
        private int V; // 存储顶点数
        private List<List<Integer>> adj; // 存储邻接表

        // 构造函数
        public Graph(int v) {
            V = v;
            adj = new ArrayList<List<Integer>>(V);
            for (int i = 0; i < V; i++) {
                adj.add(new ArrayList<Integer>());
            }
        }

        // 添加边
        public void addEdge(int from, int to) {
            adj.get(from).add(to);
        }

        // 深度优先遍历
        public void dfs(int start) {
            boolean[] visited = new boolean[V];
            dfsHelper(start, visited);
        }        

        private void dfsHelper(int u, boolean[] visited) {
            visited[u] = true;
            System.out.print(u + " ");

            for (int v : adj.get(u)) {
                if (!visited[v]) {
                    dfsHelper(v, visited);
                }
            }
        }
    }
```

在这个代码中，Graph类表示一个无向图，dfs方法表示进行深度优先遍历的函数。

dfsHelper是递归实现的帮助函数，visited数组表示节点是否被访问过。在每一次递归中，将当前节点标记为已访问，并输出其值。

然后遍历所有与当前节点相邻的未访问过的节点，并递归调用dfsHelper函数。

### 6.如何实现一个图的广度优先遍历？

```java
广度优先遍历（Breadth First Traversal）是一种图遍历算法，其核心思想是从起点开始，先访问起点所有相邻的节点，然
后按照距离逐层向外扩展，直到遍历完所有的节点。
    import java.util.*;

    class Graph {
        private int V; // 存储顶点数
        private List<List<Integer>> adj; // 存储邻接表

        // 构造函数
        public Graph(int v) {
            V = v;
            adj = new ArrayList<List<Integer>>(V);
            for (int i = 0; i < V; i++) {
                adj.add(new ArrayList<Integer>());
            }
        }

        // 添加边
        public void addEdge(int from, int to) {
            adj.get(from).add(to);
            adj.get(to).add(from); // 如果是无向图，需要加上这行
        }

        // 广度优先遍历
        public void bfs(int start) {
            boolean[] visited = new boolean[V];
            Queue<Integer> queue = new LinkedList<Integer>();

            visited[start] = true;
            queue.offer(start);
    
            while (!queue.isEmpty()) {
                int u = queue.poll();
                System.out.print(u + " ");

                for (int v : adj.get(u)) {
                    if (!visited[v]) {
                        visited[v] = true;
                        queue.offer(v);
                    }
                }
            }
        }
    }
```

在这个代码中，Graph类表示一个无向图，bfs方法表示进行广度优先遍历的函数。

visited数组表示节点是否被访问过。首先将起点标记为已访问，并将其加入队列中。然后在每一次循环中，取出队列的头部节点，输出其值，并遍历其所有未访问过的相邻节点，将其标记为已访问，并加入队列中。

循环直到队列为空。

### 7.如何找到有向图中的所有强连通分量？

在有向图中，如果对于任意的两个节点u和v，存在一条从u到v的路径和一条从v到u的路径，那么这个图就是强连通的。

而一个强连通分量是指一个最大的强连通子图。找到一个有向图的所有强连通分量可以使用Kosaraju算法或Tarjan算法。

```
    import java.util.*;

    public class Graph {
        private int V; // 存储顶点数
        private List<List<Integer>> adj; // 存储邻接表
        private int[] low; // 存储节点的low值
        private boolean[] onStack; // 判断节点是否在栈中
        private Stack<Integer> stack; // 存储已经访问过的节点
        private List<List<Integer>> scc; // 存储强连通分量
    
        // 构造函数
        public Graph(int v) {
            V = v;
            adj = new ArrayList<List<Integer>>(V);
            for (int i = 0; i < V; i++) {
                adj.add(new ArrayList<Integer>());
            }
        }

        // 添加边
        public void addEdge(int from, int to) {
            adj.get(from).add(to);
        }

        // 找到所有强连通分量
        public List<List<Integer>> tarjan() {
            low = new int[V];
            onStack = new boolean[V];
            stack = new Stack<Integer>();
            scc = new ArrayList<List<Integer>>();

            for (int i = 0; i < V; i++) {
                if (low[i] == 0) {
                    dfs(i);
                }
            }
    
            return scc;
        }

        // 深度优先搜索
        private void dfs(int u) {
            low[u] = u;
            onStack[u] = true;
            stack.push(u);

            for (int v : adj.get(u)) {
                if (low[v] == 0) {
                    dfs(v);
                    low[u] = Math.min(low[u], low[v]);
                } else if (onStack[v]) {
                    low[u] = Math.min(low[u], low[v]);
                }
            }

            if (low[u] == u) {
                List<Integer> component = new ArrayList<Integer>();
                while (true) {
                    int v = stack.pop();
                    onStack[v] = false;
                    component.add(v);
                    if (v == u) {
                        break;
                    }
                }
                scc.add(component);
            }
        }
    }
```

1.在这个代码中，Graph类表示一个有向图，tarjan方法表示使用Tarjan算法寻找所有强连通分量的函数。

2.在算法中，用low数组存储节点的low值，用onStack数组判断节点是否在栈中，用stack存储已经访问过的节点，用scc存储强连通分量。首先遍历所有节点，如果某个节点的low值为0，则从该节点开始进行深度优先搜索。

3.在搜索的过程中，如果发现某个节点的low值为0，则继续对该节点进行深

### 8.如何判断一个有向图是否存在环？

1.初始化一个 visited 数组，表示每个节点是否被访问过，初始为 false。

2.对于每个节点，从未访问过的节点开始进行 DFS 遍历。

3.在 DFS 遍历时，记录每个节点的状态：未访问、已访问但不在当前遍历栈中、已访问且在当前遍历栈中。

4.如果在 DFS 遍历的过程中发现当前节点已经在当前遍历栈中，则说明存在环。

```java
    import java.util.*;

    class DetectCycle {
        private int V; // 存储顶点数
        private List<List<Integer>> adj; // 存储邻接表

        public DetectCycle(int v) {
            V = v;
            adj = new ArrayList<List<Integer>>(V);
            for (int i = 0; i < V; i++) {
                adj.add(new ArrayList<Integer>());
            }
        }

        // 添加有向边
        public void addEdge(int from, int to) {
            adj.get(from).add(to);
        }

        // 检测环的存在
        public boolean hasCycle() {
            boolean[] visited = new boolean[V];
            boolean[] recursionStack = new boolean[V];

            // 对每个顶点运行DFS
            for (int i = 0; i < V; i++) {
                if (detectCycleUtil(i, visited, recursionStack)) {
                    return true;
                }
            }

            return false;
        }

        // DFS的工具函数，用于检测环
        private boolean detectCycleUtil(int v, boolean[] visited, boolean[] recursionStack) {
            if (recursionStack[v]) {
                return true;
            }

            if (visited[v]) {
                return false;
            }

            visited[v] = true;
            recursionStack[v] = true;

            List<Integer> neighbors = adj.get(v);
            for (int i = 0; i < neighbors.size(); i++) {
                int neighbor = neighbors.get(i);
                if (detectCycleUtil(neighbor, visited, recursionStack)) {
                    return true;
                }
            }

            recursionStack[v] = false;
    
            return false;
        }
        public static void main(String[] args) {
            DetectCycle g = new DetectCycle(4);
            g.addEdge(0, 1);
            g.addEdge(0, 2);
            g.addEdge(1, 2);
            g.addEdge(2, 0);
            g.addEdge(2, 3);
            g.addEdge(3, 3);

            if (g.hasCycle()) {
                System.out.println("存在环");
            } else {
                System.out.println("不存在环");
            }
        }
    }
```

### 9.如何使用最小生成树算法来解决一个带权无向图的最小路径问题？

最小生成树算法（如Prim和Kruskal算法）用于解决带权无向图的最小生成树问题，而不是最小路径问题。但是，可以使用一些技巧来将最小生成树算法应用于最小路径问题。

一种常见的方法是，将问题转化为最小生成树问题。具体来说，可以将带权无向图转化为一种新的图，其中每个节点表示原图中的一个点和一个方向（起点或终点），每个边表示原图中两个点之间的距离。然后，可以使用最小生成树算法找到连接起点和终点的最小路径。

另一种方法是使用Dijkstra算法。该算法可以用于带权有向图中的单源最短路径问题。因此，可以从起点开始运行Dijkstra算法，计算到每个节点的最短路径，并找到连接起点和终点的最短路径。

**使用Dijkstra算法**

```java
    import java.util.*;

    public class ShortestPath {
        private int V; // 存储顶点数
        private List<List<Edge>> adj; // 存储邻接表

        // 存储有向边的类
        private class Edge {
            int to; // 边的终点
            int weight; // 边的权值
            Edge(int to, int weight) {
                this.to = to;
                this.weight = weight;
            }
        }

        // 构造函数
        public ShortestPath(int v) {
            V = v;
            adj = new ArrayList<List<Edge>>(V);
            for (int i = 0; i < V; i++) {
                adj.add(new ArrayList<Edge>());
            }
        }

        // 添加边
        public void addEdge(int from, int to, int weight) {
            Edge e = new Edge(to, weight);
            adj.get(from).add(e);
        }

        // 使用Dijkstra算法计算最短路径
        public int dijkstra(int start, int end) {
            int[] dist = new int[V];
            Arrays.fill(dist, Integer.MAX_VALUE);
            dist[start] = 0;

            PriorityQueue<Integer> pq = new PriorityQueue<Integer>(V, new Comparator<Integer>() {
                public int compare(Integer a, Integer b) {
                    return dist[a] - dist[b];
                }
            });
            pq.offer(start);

            while (!pq.isEmpty()) {
                int u = pq.poll();
                if (u == end) {
                    break; // 如果已经到达终点，提前结束
                }
                for (Edge e : adj.get(u)) {
                    int v = e.to;
                    int weight = e.weight;
                    if (dist[u] != Integer.MAX_VALUE && dist[v] > dist[u] + weight) {
                        dist[v] = dist[u] + weight;
                        pq.offer(v);
                    }
                }
            }

            return dist[end];
        }

        public static void main(String[] args) {
            ShortestPath sp = new ShortestPath(4);
            sp.addEdge(0, 1, 1);
            sp.addEdge(0, 2, 4);
            sp.addEdge(1, 2, 2);
            sp.addEdge(2, 3, 1);
            sp.addEdge(1, 3, 5);
            int shortestPath = sp.dijkstra(0, 3);
            System.out.println("The shortest path from 0 to 3 is: " + shortestPath);
       }
   }
```

### 10.如何在一个无向加权图中找到两个节点之间的最短路径？

```java
    import java.util.*;

    class ShortestPath {
        private int V; // 存储顶点数
        private List<List<Edge>> adj; // 存储邻接表

        // 存储有向边的类
        private class Edge {
            int to; // 边的终点
            int weight; // 边的权值

            Edge(int to, int weight) {
                this.to = to;
                this.weight = weight;
            }
        }

        // 构造函数
        public ShortestPath(int v) {
            V = v;
            adj = new ArrayList<List<Edge>>(V);
            for (int i = 0; i < V; i++) {
                adj.add(new ArrayList<Edge>());
            }
        }
    
        // 添加边
        public void addEdge(int from, int to, int weight) {
            Edge e = new Edge(to, weight);
            adj.get(from).add(e);
        }

        // 使用Dijkstra算法计算最短路径
        public int dijkstra(int start, int end) {
            int[] dist = new int[V];
            Arrays.fill(dist, Integer.MAX_VALUE);
            dist[start] = 0;

            PriorityQueue<Integer> pq = new PriorityQueue<Integer>(V, new Comparator<Integer>() {
                public int compare(Integer a, Integer b) {
                    return dist[a] - dist[b];
                }
            });
            pq.offer(start);

            while (!pq.isEmpty()) {
                int u = pq.poll();
                if (u == end) {
                    break; // 如果已经到达终点，提前结束
                }
                for (Edge e : adj.get(u)) {
                    int v = e.to;
                    int weight = e.weight;
                    if (dist[u] != Integer.MAX_VALUE && dist[v] > dist[u] + weight) {    
                        dist[v] = dist[u] + weight;
                        pq.offer(v);
                    }
                }
            }

            return dist[end];
        }

        public static void main(String[] args) {
            ShortestPath sp = new ShortestPath(4);
            sp.addEdge(0, 1, 1);
            sp.addEdge(0, 2, 4);
            sp.addEdge(1, 2, 2);
            sp.addEdge(2, 3, 1);
            sp.addEdge(1, 3, 5);
            int start = 0;
            int end = 3;
            int shortestPath = sp.dijkstra(start, end);
    
            System.out.println("Shortest path from " + start + " to " + end + " is: " + shortestPath);
        }
    }
```

### 11.如何找到一个有向图中的最长路径？

在有向图中找到最长路径是一个NP难问题，即不存在多项式时间复杂度的算法。因此，需要使用指数级的算法来解决这个问题。以下是一种动态规划的方法，可以在指数级时间复杂度内找到有向图中的最长路径：

1.首先，将所有顶点按照拓扑排序的顺序进行排序。如果有环，无法进行拓扑排序，也就无法求得最长路径。

2.对于每个顶点v，初始化到该顶点的最长路径为负无穷。

3.对于每个顶点v，遍历其所有的出边e，如果存在一条从v到达e的终点w的路径长大于目前记录的到w的最长路径，则更新到w的最长路径为该路径长度。

4.遍历所有顶点后，从中找到最长的路径即可。

```
    public class LongestPath {
        private int V; // 存储顶点数
        private List<List<Edge>> adj; // 存储邻接表

        // 存储有向边的类
        private class Edge {
            int to; // 边的终点
            int weight; // 边的权值

            Edge(int to, int weight) {
                this.to = to;
                this.weight = weight;
            }
        }

        // 构造函数
        public LongestPath(int v) {
            V = v;
            adj = new ArrayList<List<Edge>>(V);
            for (int i = 0; i < V; i++) {
                adj.add(new ArrayList<Edge>());
            }
        }

        // 添加边
        public void addEdge(int from, int to, int weight) {
            Edge e = new Edge(to, weight);
            adj.get(from).add(e);
        }

        // 找到拓扑排序后的顶点序列
        private List<Integer> topologicalSort() {
            int[] indegrees = new int[V];
            for (int i = 0; i < V; i++) {
                for (Edge e : adj.get(i)) {
                    indegrees[e.to]++;
                }
            }
            Queue<Integer> queue = new LinkedList<Integer>();
            for (int i = 0; i < V; i++) {
                if (indegrees[i] == 0) {
                    queue.offer(i);
                }
            }
            List<Integer> order = new ArrayList<Integer>();
            while (!queue.isEmpty()) {
                int u = queue.poll();
                order.add(u);
                for (Edge e : adj.get(u)) {
                    int v = e.to;
                    indegrees[v]--;
                    if (indegrees[v] == 0) {
                        queue.offer(v);
                    }
                }
            }
            return order;
        }

        // 使用动态规划算法计算最长路径
        public int longestPath(int start, int end) {
            List<Integer> order = topologicalSort();
            int[] dist = new int[V];
            Arrays.fill(dist, Integer.MIN_VALUE);
            dist[start] = 0;
            for (int i = 0; i < order.size(); i++) {
                int u = order.get(i);
                if (dist[u] != Integer.MIN_VALUE) {
                    for (Edge e : adj.get(u)) {
                        int v = e.to;
                        int weight = e.weight;
                        if (dist[u] != Integer.MIN_VALUE && dist[v] < dist[u] + weight) {
                            dist[v] = dist[u] + weight;
                        }
                    }
                }
            }
            return dist[end];
        }

        public static void main(String[] args) {
            LongestPath lp = new LongestPath(6);
            lp.addEdge(0, 1, 5);
            lp.addEdge(0, 2, 3);
            lp.addEdge(1, 3, 6);
            lp.addEdge(1, 2, 2);
            lp.addEdge(2, 4, 4);
            lp.addEdge(2, 5, 2);
            lp.addEdge(2, 3, 7);
            lp.addEdge(3, 5, 1);
            int longest = lp.longestPath(1, 5);
            System.out.println(longest);

        }
    }
```

### 12.如何在一个带权图中使用 Kruskal 算法来寻找最小生成树？

Kruskal算法是一种常用的寻找带权无向图的最小生成树的算法。

其主要思想是将图中的边按照权值从小到大排序，然后依次选择边加入生成树中，直到生成树包含了所有顶点为止。

在选择边的时候，如果加入该边会导致生成树出现环，则不加入该边，直到找到下一条没有形成环的边。具体实现过程如下：

**1.** 将图中的所有边按照权值从小到大排序。

**2.** 初始化一个空的生成树，初始时生成树中不包含任何顶点。

**3.** 从权值最小的边开始依次考虑每一条边：

- • 如果加入该边会形成环，则不加入该边。

- • 如果加入该边不会形成环，则将该边加入生成树中。

**4.** 重复步骤3，直到生成树包含了所有顶点。

```java
    import java.util.*;

    public class Kruskal {
        // 边的数据结构
        static class Edge {
            int u;
            int v;
            int weight;

            Edge(int u, int v, int weight) {
                this.u = u;
                this.v = v;
                this.weight = weight;
            }
        }

        // 并查集的数据结构
        static class UnionFind {
            int[] parent;

            UnionFind(int n) {
                parent = new int[n];
                for (int i = 0; i < n; i++) {
                    parent[i] = i;
                }
            }

            int find(int x) {
                if (parent[x] != x) {
                    parent[x] = find(parent[x]);
                }
                return parent[x];
            }

            void union(int x, int y) {
                int rootX = find(x);
                int rootY = find(y);
                if (rootX != rootY) {
                    parent[rootX] = rootY;
                }
            }

            boolean isConnected(int x, int y) {
                return find(x) == find(y);
            }
        }

        static List<Edge> kruskal(List<Edge> edges, int n) {
            // 将边按照权值从小到大排序
            edges.sort((a, b) -> a.weight - b.weight);

            // 初始化并查集
            UnionFind uf = new UnionFind(n);
    
            // 初始化生成树
            List<Edge> tree = new ArrayList<>();

            // 遍历所有边
            for (Edge edge : edges) {
                int u = edge.u;
                int v = edge.v;
                int weight = edge.weight;

                // 如果加入该边不会形成环，则将该边加入生成树中
                if (!uf.isConnected(u, v)) {
                    uf.union(u, v);
                    tree.add(edge);
                }
            }

            return tree;
        }

        public static void main(String[] args) {
            // 构造一个带权无向图
            int n = 6;
            List<Edge> edges = new ArrayList<>();
            edges.add(new Edge(0, 1, 6));
            edges.add(new Edge(0, 2, 1));
            edges.add(new Edge(0, 3, 5));
            edges.add(new Edge(1, 2, 5));
            edges.add(new Edge(1, 4, 3));
            edges.add(new Edge(2, 3, 5));
            edges.add(new Edge(2, 4, 6));
            edges.add(new Edge(2, 5, 4));
            edges.add(new Edge(3, 5, 2));
            edges.add(new Edge(4, 5, 6));
    
            // 调用Kruskal算法寻找最小生成树
            List<Edge> tree = kruskal(edges, n);

            // 输出最小生成树的边
            for (Edge edge : tree) {
                System.out.println("(" + edge.u + ", " + edge.v + ", " + edge.weight + ")");
            }
        }
    }
```

- 结果为：

```
      (0, 2, 1)
      (3, 5, 2)
      (1, 4, 3)
      (1, 2, 5)
      (2, 5, 4)
```

### 13.如何在一个带权图中使用 Prim 算法来寻找最小生成树？

**1.** 随机选取一个起始点，将该点加入已访问的集合。

**2.** 从已访问的集合中选取一条权值最小的边（即与已访问的集合中的点相连且权值最小），将该边加入生成树，并将该边连接的另一个点加入已访问的集合。

**3.** 重复第2步，直到所有点都被访问。

```java
    import java.util.ArrayList;
    import java.util.List;
    import java.util.PriorityQueue;

    class PrimAlgorithm {
        static class Edge implements Comparable<Edge> {
            int v;
            int weight;

            public Edge(int v, int weight) {
                this.v = v;
                this.weight = weight;
            }

            @Override
            public int compareTo(Edge other) {
                return Integer.compare(this.weight, other.weight);
            }
        }

        public static List<Edge> prim(List<Edge>[] graph, int n) {
            List<Edge> tree = new ArrayList<>();
            boolean[] visited = new boolean[n];
            PriorityQueue<Edge> pq = new PriorityQueue<>();
            visited[0] = true;
            for (Edge edge : graph[0]) {
                pq.offer(edge);
            }
            while (!pq.isEmpty()) {
                Edge edge = pq.poll();
                if (visited[edge.v]) {
                    continue;
                }
                visited[edge.v] = true;
                tree.add(edge);
                for (Edge nextEdge : graph[edge.v]) {
                    if (!visited[nextEdge.v]) {
                        pq.offer(nextEdge);
                    }
                }
            }
            return tree;
        }

        public static void main(String[] args) {
            // 构造一个带权无向图
            int n = 6;
            List<Edge>[] graph = new List[n];
            for (int i = 0; i < n; i++) {
                graph[i] = new ArrayList<>();
            }
            graph[0].add(new Edge(1, 6));
            graph[0].add(new Edge(2, 1));
            graph[0].add(new Edge(3, 5));
            graph[1].add(new Edge(0, 6));
            graph[1].add(new Edge(2, 5));
            graph[1].add(new Edge(4, 3));
            graph[2].add(new Edge(0, 1));
            graph[2].add(new Edge(1, 5));
            graph[2].add(new Edge(3, 5));
            graph[2].add(new Edge(4, 6));
            graph[3].add(new Edge(0, 5));
            graph[3].add(new Edge(2, 5));
            graph[3].add(new Edge(4, 2));
            graph[4].add(new Edge(1, 3));
            graph[4].add(new Edge(2, 6));
            graph[4].add(new Edge(3, 2));
            graph[5].add(new Edge(2, 4));

            List<Edge> tree = prim(graph, n);

            // 输出最小生成树的边
            for (Edge edge : tree) {
                System.out.println(edge.v + " " + edge.weight);
            }
        }
    }
    /*
      2 1
      3 5
      4 2
      1 3*/
```

其中，第一列是边的一个端点的编号，第二列是该边的权值。

### 14.如何使用 Dijkstra 算法来寻找一个带权图中的最短路径？

Dijkstra 算法是一种常用的寻找带权图中最短路径的算法

```java
    import java.util.Arrays;
    import java.util.PriorityQueue;

    public class DijkstraAlgorithm {
        static class Edge implements Comparable<Edge> {
            int v;
            int weight;

            public Edge(int v, int weight) {
                this.v = v;
                this.weight = weight;
            }
    
            @Override
            public int compareTo(Edge other) {
                return Integer.compare(this.weight, other.weight);
            }
        }

        public static int[] dijkstra(int[][] graph, int start) {
            int n = graph.length;
            int[] dist = new int[n];
            boolean[] visited = new boolean[n];
            Arrays.fill(dist, Integer.MAX_VALUE);
            dist[start] = 0;
            PriorityQueue<Edge> pq = new PriorityQueue<>();
            pq.offer(new Edge(start, 0));
            while (!pq.isEmpty()) {
                Edge edge = pq.poll();
                int v = edge.v;
                if (visited[v]) {
                    continue;
                }
                visited[v] = true;
                for (int u = 0; u < n; u++) {
                    if (graph[v][u] > 0) {
                        int weight = graph[v][u];
                        if (dist[v] + weight < dist[u]) {
                            dist[u] = dist[v] + weight;
                            pq.offer(new Edge(u, dist[u]));
                        }
                    }
                }
            }
            return dist;
        }

        public static void main(String[] args) {
            // 构造一个带权有向图
            int n = 6;
            int[][] graph = new int[][]{
                    {0, 10, 0, 30, 100, 0},
                    {0, 0, 50, 0, 0, 0},
                    {0, 0, 0, 0, 10, 0},
                    {0, 0, 20, 0, 60, 0},
                    {0, 0, 0, 0, 0, 10},
                    {0, 0, 0, 0, 0, 0}
            };
            int start = 0;
            int[] dist = dijkstra(graph, start);

            // 输出从起点到其他节点的最短路径长度
            for (int i = 0; i < n; i++) {
                System.out.println("Distance from " + start + " to " + i + ": " + dist[i]);
            }
        }
    }
```

在以上示例代码中，使用了一个二维数组 graph 来表示带权有向图。其中，graph[i][j] 表示从节点 i 到节点 j 的边的权值，若没有边相连则为 0。

函数 dijkstra 接收这个二维数组以及起点 start，并返回一个一维数组 dist，其中 dist[i] 表示从起点到节点 i 的最短路径长度。

Dijkstra 算法的核心是使用一个优先队列 pq 来维护已经找到的最短路径，每次从队列中取出距离起点最近的节点，并对其未访问的邻居节点进行松弛操作，更新到起点的距离。

这样直到队列为空时，所有节点的最短路径长度就被计算出来了。

### 15.如何在一个有向图中找到两个节点之间的所有路径？

在一个有向图中，要找到两个节点之间的所有路径，可以使用深度优先搜索（DFS）算法。具体步骤如下：

1.从起点节点开始进行 DFS 搜索，记录下搜索到的路径；

2.当搜索到终点节点时，将搜索路径存储起来；

3.在回溯过程中，删除已经搜索过的节点，继续搜索下一个相邻节点，直到搜索结束。

```java
    import java.util.*;

    public class FindAllPaths {
        public static List<List<Integer>> findAllPaths(int[][] graph, int start, int end) {
            List<List<Integer>> allPaths = new ArrayList<>();
            List<Integer> curPath = new ArrayList<>();
            curPath.add(start);
            boolean[] visited = new boolean[graph.length];
            visited[start] = true;
            dfs(graph, start, end, curPath, allPaths, visited);
            return allPaths;
        }

        private static void dfs(int[][] graph, int start, int end, List<Integer> curPath, List<List<Integer>> allPaths, boolean[] visited) {
            if (start == end) {
                allPaths.add(new ArrayList<>(curPath));
                return;
            }

            for (int i = 0; i < graph.length; i++) {
                if (graph[start][i] == 1 && !visited[i]) {
                    visited[i] = true;
                    curPath.add(i);
                    dfs(graph, i, end, curPath, allPaths, visited);
                    curPath.remove(curPath.size() - 1);
                    visited[i] = false;
                }
            }
        }

        public static void main(String[] args) {
            int[][] graph = new int[][] {
                {0, 1, 1, 0, 0},
                {0, 0, 1, 1, 0},
                {0, 0, 0, 1, 1},
                {0, 0, 0, 0, 1},
                {0, 0, 0, 0, 0}
            };
            List<List<Integer>> allPaths = findAllPaths(graph, 0, 4);
            System.out.println(allPaths); // [[0, 1, 2, 3, 4], [0, 1, 3, 4], [0, 2, 3, 4]]
        }
    }
```

在以上示例代码中，通过深度优先搜索找到了从节点 0 到节点 4 的所有路径，分别是 [0, 1, 2, 3, 4]、[0, 1, 3, 4] 和 [0, 2, 3, 4]。

### 16.如何使用 Kosaraju 算法来寻找一个有向图中的强连通分量？

Kosaraju 算法是一种用于寻找有向图中强连通分量的算法，其基本思想是利用图的反向图和深度优先遍历来实现。

具体实现步骤如下：

1.对原图进行深度优先遍历，记录遍历顺序，并将遍历顺序反转得到反向图。

2.在反向图上进行深度优先遍历，并记录每个节点所在的连通分量。

```java
    import java.util.*;

    public class KosarajuAlgorithm {
        private int n; // 节点数
        private List<Integer>[] graph; // 邻接表表示的图
        private boolean[] visited; // 记录节点是否被访问过的数组

        public KosarajuAlgorithm(int n) {
            this.n = n;
            graph = new List[n];
            for (int i = 0; i < n; i++) {
                graph[i] = new ArrayList<>();
            }
            visited = new boolean[n];
        }

        public void addEdge(int u, int v) {
            graph[u].add(v);
        }

        // 第一次 DFS，得到第一次遍历顺序
        private List<Integer> firstDfs() {
            List<Integer> order = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                if (!visited[i]) {
                    dfs(i, order);
                }
            }
            Collections.reverse(order); // 将顺序反转，变为第一次遍历顺序
            return order;
        }

        // 第二次 DFS，得到强连通分量
        private List<List<Integer>> secondDfs(List<Integer> order) {
            List<List<Integer>> sccs = new ArrayList<>();
            Arrays.fill(visited, false);
            for (int i : order) {
                if (!visited[i]) {
                    List<Integer> scc = new ArrayList<>();
                    dfs(i, scc);
                    sccs.add(scc);
                }
            }
            return sccs;
        }

        // 普通的 DFS
        private void dfs(int u, List<Integer> orderOrScc) {
            visited[u] = true;
            for (int v : graph[u]) {
                if (!visited[v]) {
                    dfs(v, orderOrScc);
                }
            }
            orderOrScc.add(u);
        }

        public List<List<Integer>> getStronglyConnectedComponents() {
            List<Integer> order = firstDfs();
            return secondDfs(order);
        }

        public static void main(String[] args) {
            // 构造一个有向图
            int n = 7;
            KosarajuAlgorithm graph = new KosarajuAlgorithm(n);
            graph.addEdge(0, 1);
            graph.addEdge(1, 2);
            graph.addEdge(1, 3);
            graph.addEdge(2, 0);
            graph.addEdge(3, 4);
            graph.addEdge(4, 5);
            graph.addEdge(5, 3);
            graph.addEdge(5, 6);

            // 寻找强连通分量并输出
            List<List<Integer>> sccs = graph.getStronglyConnectedComponents();
            System.out.println("强连通分量为：");
            for (List<Integer> scc : sccs) {
                System.out.println(scc);
            }
        }
    }
```

该示例代码中，我们构建了一个有向图，并使用Kosaraju算法寻找其强连通分量。运行该程序会输出如下结果：

```
    强连通分量为：
    [0, 1, 2]
```

