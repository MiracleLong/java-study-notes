# JVM和性能调优

## JVM内存结果面试题



>  JVM是Java虚拟机（Java Virtual Machine）的缩写。JVM是一个虚拟机，它是一个计算机程序，它可以执行Java字节码，这是Java编译器生成的一种中间代码。
>
>  JVM是Java的核心，它提供了Java的跨平台能力，使得Java程序可以在任何支持Java的平台上运行，无论是Windows、Mac还是Linux等操作系统。



### 1. JVM 内存结构是什么？请描述各个区域的作用和特点。

>Java 虚拟机的内存空间分为 5 个部分：
>	程序计数器
>	Java 虚拟机栈
>	本地方法栈
>	堆
>	方法区
>
>---
>
> 1. 方法区也有一个别名叫做永久代（PermGen），但在JDK 8之后，永久代已经被移除，取而代之的是元数据区Metaspace。
> 2. 在JDK 7之前，运行时常量池也存储在方法区中，而在JDK 7之后，运行时常量池已经被移动到了堆中。
> 3. 虚拟机栈、堆、方法区和运行时常量池这四个区域在JDK 8之后被统称为Java堆

1. **程序计数器区域:** 程序计数器是一块较小的内存区域，它用于指示当前线程正在执行的字节码指令的地址。每个线程都有自己的程序计数器，它是线程私有的。在任何一个时刻，一个线程都只会执行一个方法，因此程序计数器所指向的指令是当前线程正在执行的方法的指令。
2. **Java虚拟机栈:** Java虚拟机栈也是线程私有的，用于存储方法的局部变量、操作数栈、动态链接、方法出口等信息。每当一个方法被调用时，都会在栈中创建一个新的栈帧（Stack Frame），用于存储该方法的局部变量和操作数栈等信息。当方法执行完毕后，该栈帧就会被弹出。
3. **堆:** 堆是Java虚拟机中最大的一块内存区域，它用于存储对象的实例和数组。堆是所有线程共享的，因此堆中的对象可以被所有线程访问。当一个对象不再被引用时，它就可以被垃圾回收器回收。堆中的内存分为年轻代和老年代，年轻代又分为Eden空间、Survivor空间1和Survivor空间2。新创建的对象会被分配到Eden空间中，经过一定次数的垃圾回收后仍然存活的对象会被移到Survivor空间中，最终存活的对象会被移到老年代中。
4. **方法区:** 方法区用于存储已加载的类信息、常量、静态变量、即时编译器编译后的代码等。方法区是所有线程共享的。方法区也有一个别名叫做永久代（PermGen），但在JDK 8之后，永久代已经被移除，取而代之的是Metaspace元数据区。**注意是堆内存的一部分。**
5. **运行时常量池:** 每个类都有一个运行时常量池，用于存放该类的常量。除了类的常量之外，还有一部分常量是在运行时才会被产生出来的，例如字符串常量。在JDK 7之前，运行时常量池也存储在方法区中，而在JDK 7之后，运行时常量池已经被移动到了堆中。

### 2. 程序计数器的有什么作用和特点?

**作用：**

1. 记录当前线程执行的字节码指令的地址。
2. 确定下一条将要执行的指令。
3. 记录方法调用的返回地址。
4. 确保线程能够准确地恢复上下文，从而实现线程的切换和恢复。
5. 保证多线程环境下线程之间的独立性。



**特点：**

1. 程序计数器是线程私有的，每个线程都有自己的程序计数器。
2. 程序计数器通常是一个较小的整数，可以看作是一个指针，指向方法区中的字节码指令。
3. 程序计数器的值随着线程的执行不断变化，它存储的是地址而不是具体的值。
4. 是唯一一个不会出现 OutOfMemoryError 的内存区域
5. 生命周期：随着线程的创建而创建，随着线程的结束而销毁。

### 3. 什么是堆内存？堆区内存是怎么细分的

**新生代（Young Generation）：** 也称为伊甸园区，是堆内存中的一块相对较小的内存区域，主要用于存储新创建的对象实例。新生代又分为三个部分：

- **Eden区：** 是新生代中的一个内存区域，是对象最初被创建的地方。
- **Survivor区：** 是新生代中的另一个内存区域，用于存储从Eden区中经过第一次垃圾回收后仍然存活的对象。
- **To-Space区：** 也是新生代中的一个内存区域，用于存储由Survivor区中存活的对象所复制的对象。

**老年代（Old Generation）：** 也称为年老堆区，是堆内存中的一块相对较大的内存区域，用于存储已经经过多次垃圾回收仍然存活的对象。当Eden区和Survivor区中的对象存活时间越来越长时，它们就会被复制到老年代中。

**永久代（Perm Generation）：** 也称为持久堆区，是堆内存中的另一个内存区域，主要用于存储静态数据、类信息、常量池以及字符串常量等数据。注意，Perm Generation在JDK 8之后被移除，被称为元数据区（Metaspace），它是在本地内存中实现的。

### 4. 什么是栈内存？

> 在JVM中，栈内存是一种用于存储方法调用和本地变量的内存区域。
>
> 每当一个线程执行一个方法时，JVM都会为该方法创建一个新的栈帧，并将其压入该线程的栈中。
>
> 栈帧包含该方法的局部变量、操作数栈和返回值等信息。
>
> 当该方法执行完成后，该栈帧会被弹出栈。
>
> 栈内存是一种线程私有的内存区域，因此每个线程都有自己的栈。
>
> 在JVM中，栈的大小是固定的，由JVM参数来控制。
>
> 如果在执行方法时栈空间不足，将抛出StackOverflowError错误。

1. 栈内存是一种内存区域，用于存储方法调用和本地变量。
2.  每当一个方法被调用时，JVM 会为该方法创建一个新的栈帧并将其压入当前线程的栈中。
3. 栈帧包含了该方法的参数、局部变量、操作数栈和返回值等信息。
4. 栈帧有一个固定的格式，包括局部变量表、操作数栈、动态链接、方法返回地址和附加信息等几个部分。
5. 局部变量表用于存储方法中定义的局部变量，包括基本数据类型和对象引用等。
6. 操作数栈用于存储计算过程中的中间结果和方法参数等。
7. 动态链接用于支持动态方法调用。
8.  方法返回地址记录方法调用完成后的返回地址。
9. 附加信息用于存储与调试相关的信息，例如方法的调试符号表等。

### 5. Java虚拟机栈如何进行方法计算的

​	当一个方法被调用时，Java虚拟机会为该方法创建一个新的栈帧，并将其压入栈顶。栈帧包含了该方法的局部变量表、操作数栈、返回地址等运行时数据。其中，局部变量表用于存储方法参数和局部变量，而操作数栈则用于进行计算操作。

​	在方法的执行过程中，Java虚拟机会根据字节码指令从操作数栈中取出所需的操作数，并进行相应的计算。计算结果会再次被压入操作数栈中，供下一条指令使用。如果操作数栈中没有足够的操作数，则会抛出栈异常(StackUnderflowException)。

​	当方法执行完成时，Java虚拟机会将该栈帧从栈中弹出，并将控制权返回到上一个栈帧，继续执行上一个方法。如果当前栈帧是最后一个栈帧，那么程序执行就结束了。

​	**需要注意**的是，Java虚拟机栈的大小是有限制的。如果栈帧过多或栈深度过深，可能会导致栈溢出(StackOverflowError)异常。因此，在编写Java程序时，需要注意方法的递归调用、参数传递等情况，避免出现栈溢出等问题。

### 6. 什么是直接内存？它与堆内存有什么区别和联系？它的使用场景是什么？

​	当Java程序需要使用大量数据或需要快速读写数据时，通常会使用直接内存。

​	直接内存是一种由Java虚拟机管理的内存分配区域，但它不同于Java堆内存。直接内存的分配和释放由操作系统负责，而非由Java虚拟机进行管理，这意味着直接内存可以在Java堆内存之外直接分配。

​	此外，直接内存可以通过Java NIO（New IO）库中的ByteBuffer类进行操作，而Java堆内存则是通过Java程序中的new关键字进行分配。

​	直接内存相对于Java堆内存具有以下优点：

**1.提高性能：** 由于直接内存是由操作系统管理的，而且在操作系统中通常是以页为单位进行管理，因此直接内存的访问速度比Java堆内存快，尤其是在需要频繁读写的情况下。

**2.减少内存拷贝：** 在进行网络数据传输或文件IO等操作时，通常需要将数据从内存中拷贝到网络或磁盘中，再从网络或磁盘中读取数据。使用直接内存可以避免将数据从Java堆内存中拷贝到直接内存中，从而减少内存拷贝的次数。

**3.增加可用内存：** 由于直接内存不受Java虚拟机堆内存的限制，因此可以允许程序使用更多的内存。同时，由于直接内存的分配和释放由操作系统负责，因此可以在Java堆内存中达到更高的内存利用率。

**使用场景包括：**

**1.大数据处理：** 如果Java程序需要处理大量数据，使用直接内存可以显著提高处理速度。

**2.网络数据传输：** 直接内存可以减少将数据从Java堆内存中拷贝到直接内存中的次数，从而提高网络数据传输的效率。

**3.文件IO：** 直接内存可以避免将数据从Java堆内存中拷贝到直接内存中，从而提高文件IO的效率。

示例代码：

```java
 	import java.io.*;
    import java.nio.ByteBuffer;
    import java.nio.channels.FileChannel;

    public class FileCopyExample {
        public static void main(String[] args) throws IOException {
            String srcPath = "source.txt";
            String destPath = "destination.txt";
        
            // 使用直接内存创建输入流和输出流
            try (FileInputStream fis = new FileInputStream(srcPath);
                 FileOutputStream fos = new FileOutputStream(destPath);
                 FileChannel inputChannel = fis.getChannel();
                 FileChannel outputChannel = fos.getChannel()) {
            
                // 分配直接内存缓冲区
                ByteBuffer buffer = ByteBuffer.allocateDirect(1024 * 1024);
            
                // 从输入通道读取数据并写入输出通道
                while (inputChannel.read(buffer) != -1) {
                    buffer.flip();
                    outputChannel.write(buffer);
                    buffer.clear();
                }
            }
        }
    }
```

### 7. 永久代和元空间内存使用上的差异？

​	永久代和元空间都是用于存储Java类相关信息的内存区域，但它们在内存使用上有以下差异：

**1.内存分配方式：** 永久代是使用JVM堆内存来存储类相关信息的，而元空间是使用本地内存（即直接内存）来存储类相关信息的。

**2.内存大小：** 永久代的大小是有限制的，一般情况下默认大小是64MB，可以通过JVM参数进行调整。而元空间的大小不受限制，会根据应用程序的需要动态分配内存，当内存不足时会自动扩容。

**3.垃圾回收机制：** 永久代的垃圾回收机制是基于JVM垃圾收集器的标记-清除算法，当永久代的空间不足时，JVM会触发Full GC来回收无用的类相关信息。而元空间使用的是Java堆内存的垃圾收集器（例如CMS或G1），垃圾回收的触发和过程与Java堆内存相同。

**4.类的卸载：** 由于永久代是使用JVM堆内存来存储类信息的，当一个类不再被使用时，它所占用的内存空间无法被回收，直到JVM进程结束。而元空间使用的是本地内存，当一个类不再被使用时，对应的内存空间可以被垃圾收集器回收，从而避免了永久代中的“永久性”问题。

### 8. 为什么使用元空间替代永久代作为方法区的实现？

在JDK 8之前，Java虚拟机使用永久代来实现方法区。然而，永久代存在一些问题，例如：

**1.有限的空间：** 永久代的大小是有限制的，一旦空间满了就会导致OutOfMemoryError异常。

**2.垃圾回收效率低：** 永久代的垃圾回收效率低下，因为它使用的是标记-清除算法，容易出现内存碎片。

**3.无法动态调整大小：** 永久代的大小在启动JVM时就已经确定了，无法在运行时动态调整大小。



因此，从JDK 8开始，Java虚拟机引入了元空间来代替永久代作为方法区的实现。元空间相比永久代，具有以下优势：

**1.动态分配内存：** 元空间使用的是本地内存，内存空间可以根据应用程序的需要动态分配，不会受到永久代的大小限制。

**2.垃圾回收效率高：** 元空间使用的是Java堆内存的垃圾收集器（例如CMS或G1），垃圾回收的触发和过程与Java堆内存相同，因此垃圾回收效率更高。

**3.类卸载更彻底：** 由于元空间使用的是本地内存，当一个类不再被使用时，对应的内存空间可以被垃圾收集器回收，从而避免了永久代中的“永久性”问题。

**4.管理更灵活：** 元空间可以通过JVM参数进行配置，例如设置元空间的最大大小、元空间内存的回收策略等。

因此，使用元空间代替永久代作为方法区的实现，可以提高内存的利用率和垃圾回收效率，同时也能够更灵活地管理内存空间。