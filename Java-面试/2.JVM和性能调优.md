# JVM和性能调优

## 1.JVM内存结果面试题



>  JVM是Java虚拟机（Java Virtual Machine）的缩写。JVM是一个虚拟机，它是一个计算机程序，它可以执行Java字节码，这是Java编译器生成的一种中间代码。
>
>  JVM是Java的核心，它提供了Java的跨平台能力，使得Java程序可以在任何支持Java的平台上运行，无论是Windows、Mac还是Linux等操作系统。



### 1. JVM 内存结构是什么？请描述各个区域的作用和特点。

>Java 虚拟机的内存空间分为 5 个部分：
>	程序计数器
>	Java 虚拟机栈
>	本地方法栈
>	堆
>	方法区
>
>---
>
> 1. 方法区也有一个别名叫做永久代（PermGen），但在JDK 8之后，永久代已经被移除，取而代之的是元数据区Metaspace。
> 2. 在JDK 7之前，运行时常量池也存储在方法区中，而在JDK 7之后，运行时常量池已经被移动到了堆中。
> 3. 虚拟机栈、堆、方法区和运行时常量池这四个区域在JDK 8之后被统称为Java堆

1. **程序计数器区域:** 程序计数器是一块较小的内存区域，它用于指示当前线程正在执行的字节码指令的地址。每个线程都有自己的程序计数器，它是线程私有的。在任何一个时刻，一个线程都只会执行一个方法，因此程序计数器所指向的指令是当前线程正在执行的方法的指令。
2. **Java虚拟机栈:** Java虚拟机栈也是线程私有的，用于存储方法的局部变量、操作数栈、动态链接、方法出口等信息。每当一个方法被调用时，都会在栈中创建一个新的栈帧（Stack Frame），用于存储该方法的局部变量和操作数栈等信息。当方法执行完毕后，该栈帧就会被弹出。
3. **堆:** 堆是Java虚拟机中最大的一块内存区域，它用于存储对象的实例和数组。堆是所有线程共享的，因此堆中的对象可以被所有线程访问。当一个对象不再被引用时，它就可以被垃圾回收器回收。堆中的内存分为年轻代和老年代，年轻代又分为Eden空间、Survivor空间1和Survivor空间2。新创建的对象会被分配到Eden空间中，经过一定次数的垃圾回收后仍然存活的对象会被移到Survivor空间中，最终存活的对象会被移到老年代中。
4. **方法区:** 方法区用于存储已加载的类信息、常量、静态变量、即时编译器编译后的代码等。方法区是所有线程共享的。方法区也有一个别名叫做永久代（PermGen），但在JDK 8之后，永久代已经被移除，取而代之的是Metaspace元数据区。**注意是堆内存的一部分。**
5. **运行时常量池:** 每个类都有一个运行时常量池，用于存放该类的常量。除了类的常量之外，还有一部分常量是在运行时才会被产生出来的，例如字符串常量。在JDK 7之前，运行时常量池也存储在方法区中，而在JDK 7之后，运行时常量池已经被移动到了堆中。

### 2. 程序计数器的有什么作用和特点?

**作用：**

1. 记录当前线程执行的字节码指令的地址。
2. 确定下一条将要执行的指令。
3. 记录方法调用的返回地址。
4. 确保线程能够准确地恢复上下文，从而实现线程的切换和恢复。
5. 保证多线程环境下线程之间的独立性。



**特点：**

1. 程序计数器是线程私有的，每个线程都有自己的程序计数器。
2. 程序计数器通常是一个较小的整数，可以看作是一个指针，指向方法区中的字节码指令。
3. 程序计数器的值随着线程的执行不断变化，它存储的是地址而不是具体的值。
4. 是唯一一个不会出现 OutOfMemoryError 的内存区域
5. 生命周期：随着线程的创建而创建，随着线程的结束而销毁。

### 3. 什么是堆内存？堆区内存是怎么细分的

**新生代（Young Generation）：** 也称为伊甸园区，是堆内存中的一块相对较小的内存区域，主要用于存储新创建的对象实例。新生代又分为三个部分：

- **Eden区：** 是新生代中的一个内存区域，是对象最初被创建的地方。
- **Survivor区：** 是新生代中的另一个内存区域，用于存储从Eden区中经过第一次垃圾回收后仍然存活的对象。
- **To-Space区：** 也是新生代中的一个内存区域，用于存储由Survivor区中存活的对象所复制的对象。

**老年代（Old Generation）：** 也称为年老堆区，是堆内存中的一块相对较大的内存区域，用于存储已经经过多次垃圾回收仍然存活的对象。当Eden区和Survivor区中的对象存活时间越来越长时，它们就会被复制到老年代中。

**永久代（Perm Generation）：** 也称为持久堆区，是堆内存中的另一个内存区域，主要用于存储静态数据、类信息、常量池以及字符串常量等数据。注意，Perm Generation在JDK 8之后被移除，被称为元数据区（Metaspace），它是在本地内存中实现的。

### 4. 什么是栈内存？

> 在JVM中，栈内存是一种用于存储方法调用和本地变量的内存区域。
>
> 每当一个线程执行一个方法时，JVM都会为该方法创建一个新的栈帧，并将其压入该线程的栈中。
>
> 栈帧包含该方法的局部变量、操作数栈和返回值等信息。
>
> 当该方法执行完成后，该栈帧会被弹出栈。
>
> 栈内存是一种线程私有的内存区域，因此每个线程都有自己的栈。
>
> 在JVM中，栈的大小是固定的，由JVM参数来控制。
>
> 如果在执行方法时栈空间不足，将抛出StackOverflowError错误。

1. 栈内存是一种内存区域，用于存储方法调用和本地变量。
2.  每当一个方法被调用时，JVM 会为该方法创建一个新的栈帧并将其压入当前线程的栈中。
3. 栈帧包含了该方法的参数、局部变量、操作数栈和返回值等信息。
4. 栈帧有一个固定的格式，包括局部变量表、操作数栈、动态链接、方法返回地址和附加信息等几个部分。
5. 局部变量表用于存储方法中定义的局部变量，包括基本数据类型和对象引用等。
6. 操作数栈用于存储计算过程中的中间结果和方法参数等。
7. 动态链接用于支持动态方法调用。
8.  方法返回地址记录方法调用完成后的返回地址。
9. 附加信息用于存储与调试相关的信息，例如方法的调试符号表等。

### 5. Java虚拟机栈如何进行方法计算的

​	当一个方法被调用时，Java虚拟机会为该方法创建一个新的栈帧，并将其压入栈顶。栈帧包含了该方法的局部变量表、操作数栈、返回地址等运行时数据。其中，局部变量表用于存储方法参数和局部变量，而操作数栈则用于进行计算操作。

​	在方法的执行过程中，Java虚拟机会根据字节码指令从操作数栈中取出所需的操作数，并进行相应的计算。计算结果会再次被压入操作数栈中，供下一条指令使用。如果操作数栈中没有足够的操作数，则会抛出栈异常(StackUnderflowException)。

​	当方法执行完成时，Java虚拟机会将该栈帧从栈中弹出，并将控制权返回到上一个栈帧，继续执行上一个方法。如果当前栈帧是最后一个栈帧，那么程序执行就结束了。

​	**需要注意**的是，Java虚拟机栈的大小是有限制的。如果栈帧过多或栈深度过深，可能会导致栈溢出(StackOverflowError)异常。因此，在编写Java程序时，需要注意方法的递归调用、参数传递等情况，避免出现栈溢出等问题。

### 6. 什么是直接内存？它与堆内存有什么区别和联系？它的使用场景是什么？

​	当Java程序需要使用大量数据或需要快速读写数据时，通常会使用直接内存。

​	直接内存是一种由Java虚拟机管理的内存分配区域，但它不同于Java堆内存。直接内存的分配和释放由操作系统负责，而非由Java虚拟机进行管理，这意味着直接内存可以在Java堆内存之外直接分配。

​	此外，直接内存可以通过Java NIO（New IO）库中的ByteBuffer类进行操作，而Java堆内存则是通过Java程序中的new关键字进行分配。

​	直接内存相对于Java堆内存具有以下优点：

**1.提高性能：** 由于直接内存是由操作系统管理的，而且在操作系统中通常是以页为单位进行管理，因此直接内存的访问速度比Java堆内存快，尤其是在需要频繁读写的情况下。

**2.减少内存拷贝：** 在进行网络数据传输或文件IO等操作时，通常需要将数据从内存中拷贝到网络或磁盘中，再从网络或磁盘中读取数据。使用直接内存可以避免将数据从Java堆内存中拷贝到直接内存中，从而减少内存拷贝的次数。

**3.增加可用内存：** 由于直接内存不受Java虚拟机堆内存的限制，因此可以允许程序使用更多的内存。同时，由于直接内存的分配和释放由操作系统负责，因此可以在Java堆内存中达到更高的内存利用率。

**使用场景包括：**

**1.大数据处理：** 如果Java程序需要处理大量数据，使用直接内存可以显著提高处理速度。

**2.网络数据传输：** 直接内存可以减少将数据从Java堆内存中拷贝到直接内存中的次数，从而提高网络数据传输的效率。

**3.文件IO：** 直接内存可以避免将数据从Java堆内存中拷贝到直接内存中，从而提高文件IO的效率。

示例代码：

```java
 	import java.io.*;
    import java.nio.ByteBuffer;
    import java.nio.channels.FileChannel;

    public class FileCopyExample {
        public static void main(String[] args) throws IOException {
            String srcPath = "source.txt";
            String destPath = "destination.txt";
        
            // 使用直接内存创建输入流和输出流
            try (FileInputStream fis = new FileInputStream(srcPath);
                 FileOutputStream fos = new FileOutputStream(destPath);
                 FileChannel inputChannel = fis.getChannel();
                 FileChannel outputChannel = fos.getChannel()) {
            
                // 分配直接内存缓冲区
                ByteBuffer buffer = ByteBuffer.allocateDirect(1024 * 1024);
            
                // 从输入通道读取数据并写入输出通道
                while (inputChannel.read(buffer) != -1) {
                    buffer.flip();
                    outputChannel.write(buffer);
                    buffer.clear();
                }
            }
        }
    }
```

### 7. 永久代和元空间内存使用上的差异？

​	永久代和元空间都是用于存储Java类相关信息的内存区域，但它们在内存使用上有以下差异：

**1.内存分配方式：** 永久代是使用JVM堆内存来存储类相关信息的，而元空间是使用本地内存（即直接内存）来存储类相关信息的。

**2.内存大小：** 永久代的大小是有限制的，一般情况下默认大小是64MB，可以通过JVM参数进行调整。而元空间的大小不受限制，会根据应用程序的需要动态分配内存，当内存不足时会自动扩容。

**3.垃圾回收机制：** 永久代的垃圾回收机制是基于JVM垃圾收集器的标记-清除算法，当永久代的空间不足时，JVM会触发Full GC来回收无用的类相关信息。而元空间使用的是Java堆内存的垃圾收集器（例如CMS或G1），垃圾回收的触发和过程与Java堆内存相同。

**4.类的卸载：** 由于永久代是使用JVM堆内存来存储类信息的，当一个类不再被使用时，它所占用的内存空间无法被回收，直到JVM进程结束。而元空间使用的是本地内存，当一个类不再被使用时，对应的内存空间可以被垃圾收集器回收，从而避免了永久代中的“永久性”问题。

### 8. 为什么使用元空间替代永久代作为方法区的实现？

在JDK 8之前，Java虚拟机使用永久代来实现方法区。然而，永久代存在一些问题，例如：

**1.有限的空间：** 永久代的大小是有限制的，一旦空间满了就会导致OutOfMemoryError异常。

**2.垃圾回收效率低：** 永久代的垃圾回收效率低下，因为它使用的是标记-清除算法，容易出现内存碎片。

**3.无法动态调整大小：** 永久代的大小在启动JVM时就已经确定了，无法在运行时动态调整大小。



因此，从JDK 8开始，Java虚拟机引入了元空间来代替永久代作为方法区的实现。元空间相比永久代，具有以下优势：

**1.动态分配内存：** 元空间使用的是本地内存，内存空间可以根据应用程序的需要动态分配，不会受到永久代的大小限制。

**2.垃圾回收效率高：** 元空间使用的是Java堆内存的垃圾收集器（例如CMS或G1），垃圾回收的触发和过程与Java堆内存相同，因此垃圾回收效率更高。

**3.类卸载更彻底：** 由于元空间使用的是本地内存，当一个类不再被使用时，对应的内存空间可以被垃圾收集器回收，从而避免了永久代中的“永久性”问题。

**4.管理更灵活：** 元空间可以通过JVM参数进行配置，例如设置元空间的最大大小、元空间内存的回收策略等。

因此，使用元空间代替永久代作为方法区的实现，可以提高内存的利用率和垃圾回收效率，同时也能够更灵活地管理内存空间。





## 2.JVM垃圾回收面试题



### 1. 什么是JVM垃圾回收机制，它是如何工作的？

>   JVM（Java虚拟机）垃圾回收机制是一种自动内存管理技术，用于回收不再被程序使用的内存空间。
>   它的工作原理是通过监控程序运行时使用的对象和内存空间，自动识别不再使用的对象并释放它们所占用的内存空间，从而保证程序的内存使用效率。

​	JVM垃圾回收机制会将内存分为不同的区域，包括年轻代（Young Generation）、老年代（Old Generation）和永久代（Permanent Generation）。

​	年轻代存储的是新创建的对象，老年代存储的是经过多次垃圾回收仍然存活的对象，而永久代则是用于存储JVM运行时需要的类、方法等元数据。

​	JVM垃圾回收机制的具体工作流程如下：

​	**1.标记（Marking）** ：JVM会从根对象（即被程序直接引用的对象）开始遍历内存中的所有对象，标记那些仍然存活的对象。

​	**2.清除（Sweeping）** ：JVM会清除所有未被标记的对象所占用的内存空间。

​	**3.整理（Compacting）** ：如果清除了大量的内存空间，JVM会将剩余的对象整理到一起，以减少内存碎片的产生，提高内存使用效率。

​	JVM垃圾回收机制的具体实现可以有多种，包括标记-清除算法、复制算法、标记-整理算法和分代收集算法等。不同的算法有不同的优缺点，可以根据具体的应用场景选择适合的算法。

### 2. JVM中有哪些垃圾回收算法？它们的优缺点分别是什么？

|     算法      | 优点                                                         | 缺点                                                         |
| :-----------: | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 标记-清除算法 | 实现简单  不需要移动对象  可以处理任意类型的数据结构         | 清除未标记的对象会产生大量内存碎片，影响内存的使用效率。  标记和清除的效率都比较低，不适用于大规模的内存回收。 |
|   复制算法    | 回收效率高。  不会产生内存碎片。                             | 需要额外的内存空间来存储复制的对象，对于大规模的对象存储会造成较大的开销。  只能使用一半的内存空间，无法充分利用内存资源。 |
| 标记-整理算法 | 不会产生内存碎片  回收效率比标记-清除算法高                  | 需要移动对象，可能会对程序的性能产生影响                     |
| 分代收集算法  | 可以根据对象的特点进行有效的回收，提高回收效率  能够充分利用内存空间，提高内存的使用效率 | 需要维护多个代，增加了内存管理的复杂度  需要判断对象的年龄，增加了回收的成本 |

### 3. 什么是对象引用？JVM中有哪些类型的对象引用？

>   对象引用是指一个变量或者表达式，通过它们可以访问内存中的某个对象。
>   在Java程序中，所有的数据都是以对象的形式存在的，对象引用就是用来操作这些对象的。

​	JVM中有以下几种类型的对象引用：

​	**强引用（Strong Reference）:** 如果一个对象具有强引用，那么垃圾回收器绝不会回收这个对象。当内存空间不足时，JVM会抛出OutOfMemoryError错误。

​	**软引用（Soft Reference）:** 如果一个对象具有软引用，在内存空间不足时，垃圾回收器可能会回收这个对象。软引用通常用于实现内存敏感的缓存，如果内存空间足够，则保留缓存数据，否则释放缓存数据。

​	**弱引用（Weak Reference）:** 如果一个对象具有弱引用，在下一次垃圾回收时，垃圾回收器会回收这个对象。弱引用通常用于实现内存敏感的高速缓存，当缓存中的数据被回收时，弱引用可以起到通知的作用。

​	**虚引用（Phantom Reference）:** 虚引用是最弱的一种引用，一个对象具有虚引用的唯一目的就是能在这个对象被垃圾回收器回收时收到一个系统通知。虚引用通常被用来管理直接内存，比如使用NIO进行内存映射时。

### 4. 如何避免JVM垃圾回收导致的性能问题？

​	JVM垃圾回收是自动化的内存管理机制，它可以减轻开发者的内存管理负担，但是如果不合理地使用垃圾回收机制，会导致应用程序的性能问题。以下是一些避免JVM垃圾回收导致的性能问题的建议：

​	**1.尽可能地使用局部变量：** 在方法内部定义的变量（局部变量）会在方法结束时自动释放，不会占用过多的内存，也不会成为垃圾回收的对象。如果使用全局变量，需要手动释放内存，容易出现内存泄漏和性能问题。

​	**2.限制字符串的使用：** 字符串是一种不可变的对象，当频繁地创建和销毁字符串对象时，会对垃圾回收机制产生很大的压力。尽可能地重用字符串对象，或者使用StringBuilder等可变字符串类来减少字符串对象的创建和销毁。

​	**3.尽可能地使用基本数据类型：** 基本数据类型比对象更加轻量级，不会占用过多的内存，也不会成为垃圾回收的对象。如果使用对象类型，需要手动释放内存，容易出现内存泄漏和性能问题。

​	**4.避免创建过多的对象：** 当创建过多的对象时，会对垃圾回收机制产生很大的压力，导致应用程序的性能问题。尽可能地重用对象，或者使用对象池等技术来减少对象的创建和销毁。

​	**5.使用合理的数据结构：** 使用合理的数据结构可以减少对象的创建和销毁，降低垃圾回收的压力，提高程序的性能。例如，使用数组代替集合类可以减少对象的创建和销毁，使用缓存可以重复利用对象，避免重复创建对象。

### 5. 什么是内存泄漏？JVM中如何检测和避免内存泄漏问题？

假设有一个简单的Java应用程序，它读取大量数据并将其保存在内存中，然后将结果输出到文件。该应用程序有一个名为DataProcessor的类，其代码如下:

```java
    public class DataProcessor {
        private List<Data> dataList = new ArrayList<>();
    
        public void processData() {
            // 读取大量数据
            while (hasMoreData()) {
                Data data = readData();
                dataList.add(data);
            }
            // 处理数据
            for (Data data : dataList) {
                process(data);
            }
            // 输出结果
            writeResultToFile();
        }
    
        private boolean hasMoreData() {
            // 省略实现
        }
    
        private Data readData() {
           // 省略实现
        }
    
        private void process(Data data) {
           // 省略实现
        }
    
        private void writeResultToFile() {
            // 省略实现
        }
    }

```

​	在这个例子中，DataProcessor类有一个私有的List字段，用于保存读取的数据。当processData方法被调用时，它会读取大量数据并将其保存在dataList中，然后处理数据并输出结果。

​	但是，如果没有正确地管理dataList，就可能会导致内存泄漏问题。例如，在处理数据之前，如果忘记清空dataList，就会导致已经处理过的数据仍然存在于内存中，从而导致内存泄漏。

​	为了分析这个例子中的内存泄漏问题，可以使用以下步骤：

​	1.监控应用程序的内存使用情况，例如使用jconsole工具。如果发现应用程序的内存使用量在持续增长，就可能存在内存泄漏问题。

​	2.使用jmap命令导出JVM的堆内存信息。具体操作如下：

```shell
jmap -dump:format=b,file=heap.bin <pid>
```

​	其中，"<pid>"为JVM的进程ID

​	3.使用内存分析工具（如Eclipse Memory Analyzer）打开heap.bin文件，并分析对象分布和内存使用情况等信息。在这个例子中，可以查看DataProcessor类的实例和dataList字段的信息，以确定是否存在内存泄漏问题。

​	4.如果发现内存泄漏问题，可以使用工具分析对象引用链，找到导致内存泄漏的根本原因。在这个例子中，可以查看哪些对象引用了DataProcessor实例和dataList对象，并分析这些对象是否正确地被垃圾回收。

### 6. JVM中有哪些工具可以用于分析和调试垃圾回收相关的问题？

- **jstat：** 可以监控JVM的GC情况，包括每种GC的次数、时间、堆内存使用情况等信息。

```shell
jstat -gcutil <pid> <interval> <count>
```

- **jmap：** 可以输出JVM的堆内存信息，包括对象分布、内存使用情况等信息。通常用于分析内存泄漏等问题。

```shell
jmap -dump:format=b,file=heap.bin <pid>
```

- **jstack：** 可以输出JVM的线程信息，包括线程状态、调用栈等信息。通常用于分析死锁等问题。

```shell
jstack -l <pid>
```

​	**VisualVM：** 一个功能强大的性能分析工具，可以监控JVM的GC、线程、内存使用情况等信息，同时还支持内存分析、CPU性能分析、线程分析等功能。

​	**Eclipse Memory Analyzer：** 一个专业的内存分析工具，可以分析JVM的堆内存信息，包括对象分布、内存泄漏等问题。

​	除了上述工具外，还有一些第三方工具，如jconsole、YourKit等，也可以用于分析和调试垃圾回收相关的问题。

### 7. 如何调整JVM的垃圾回收参数以达到更好的性能和吞吐量？

​	调整JVM的垃圾回收参数可以优化应用程序的性能和吞吐量，但需要根据具体应用程序的场景和需求进行优化，因为不同的应用程序在运行时的内存占用和GC情况可能会有很大的差异。以下是一些常用的JVM垃圾回收参数及其对应的作用：

- **-Xms和-Xmx：** 设置JVM堆内存的初始大小和最大大小，可以通过适当调整这两个参数来达到更好的性能和吞吐量。

- **-XX:+UseParallelGC：** 使用并行垃圾回收器，可以提高垃圾回收的效率，但会占用更多的CPU资源。

- **-XX:+UseConcMarkSweepGC：** 使用CMS垃圾回收器，可以在不停止应用程序的情况下进行垃圾回收，适用于具有大量长时间存活对象的应用程序。

- **-XX:NewRatio：** 设置新生代和老年代的比例，默认为2，即新生代和老年代的大小比为1:2。

- **-XX:SurvivorRatio：** 设置survivor区和eden区的比例，默认为8，即survivor区大小为eden区的1/8。

- **-XX:MaxGCPauseMillis：** 设置最大垃圾回收暂停时间的目标值，如果GC暂停时间超过该值，则会尝试自动调整垃圾回收器的参数以达到该目标值。

- **-XX:+UseG1GC：** 使用G1垃圾回收器，可以在不停止应用程序的情况下进行高效的垃圾回收，并尽量减少GC暂停时间。

  调整JVM的垃圾回收参数需要谨慎，建议先进行测试和性能分析，根据实际情况进行优化。

### 8. 什么是G1垃圾回收器，它相较于其他垃圾回收器有何优势和不同之处？

​	G1 (Garbage First) 垃圾回收器是JDK 7 Update 4版本引入的一种新型垃圾回收器，它是一种基于分代的垃圾回收器，能够在不牺牲吞吐量的情况下，更好地保证低延迟的性能，能够处理大型内存和多核CPU的应用程序。

​	G1垃圾回收器相较于其他垃圾回收器的优势和不同之处主要有以下几点：

- **分代垃圾回收器：** G1垃圾回收器采用了分代垃圾回收器的思想，将堆内存分为不同的区域，可以更好地管理和控制不同对象的生命周期，有效减少Full GC的发生。

- **并发和增量回收：** G1垃圾回收器采用了并发和增量回收的方式，可以在应用程序运行的同时进行垃圾回收，减少了GC暂停时间，提高了应用程序的响应性能和吞吐量。

- **预测性能：** G1垃圾回收器可以根据应用程序的实际情况预测垃圾回收的成本和时间，根据预测结果来优化垃圾回收的策略和参数，进一步提高垃圾回收的效率。

- **空间整理：** G1垃圾回收器可以在进行垃圾回收的同时进行空间整理，将碎片化的内存区域合并为更大的内存块，减少了内存碎片的发生。

- **可预测停顿：** G1垃圾回收器可以通过设置最大垃圾回收暂停时间的目标值，来尽量减少垃圾回收的暂停时间，实现可预测的停顿。

  需要注意的是，G1垃圾回收器在处理大内存应用程序时，可以显著提高性能和吞吐量，但对于小型应用程序来说，可能会带来额外的开销，因此需要根据实际应用场景进行选择。

  同时，G1垃圾回收器的默认设置可能不适用于所有应用程序，需要根据具体的情况进行参数调整和优化。

### 9. JVM中的年轻代和老年代如何进行对象的分配和回收？

​	JVM中的年轻代和老年代是Java虚拟机堆内存的两个重要部分。年轻代主要用于存储新创建的对象，而老年代则用于存储经过多次垃圾回收后仍然存活的对象。在JVM中，对象的分配和回收是由垃圾回收器（Garbage Collector，GC）负责的。

当一个新的对象被创建时，JVM会将其分配到年轻代的Eden区中。

如果Eden区没有足够的空间来存储对象，则JVM会触发一次年轻代的垃圾回收。

在垃圾回收过程中，垃圾回收器会标记并清除所有已经死亡的对象，然后将幸存下来的对象移动到年轻代的Survivor区中。

- 在Survivor区中存活了一定时间后的对象，将会被移动到另一个Survivor区中。

- 当一个对象在Survivor区中存活了一定时间后，它将被移动到老年代中。

- 对于年轻代中的垃圾回收，一般使用的是基于标记-复制算法的垃圾回收器。在这种算法中，JVM将年轻代分为Eden区和两个Survivor区。当一个Survivor区中的对象数量达到一定的阈值时，其中的对象将被移动到老年代中。

- 在老年代中，通常使用的是基于标记-清除或标记-整理算法的垃圾回收器。

- 标记-清除算法在清除未被标记对象的同时可能会导致堆内存的碎片化，而标记-整理算法则会在清除未被标记对象的同时整理存活的对象，使得堆内存中的空间更加连续。

  JVM的垃圾回收器会自动管理内存，不需要手动分配或释放对象所占用的内存

## 3.JVM类加载面试题

### 1. 什么是类加载器（Class Loader）？它们的作用是什么？

​	类加载器（Class Loader）是 Java 虚拟机（JVM）的一个重要组成部分，其主要作用是在运行时动态地加载 Java 类并将其转换为 Java 程序可以使用的二进制代码。

​	在 Java 程序运行时，如果需要使用某个类，JVM 会通过类加载器来查找并加载该类。类加载器负责读取类文件（通常是以 .class 文件的形式存在的字节码文件），并将其转换为 JVM 内部的二进制格式，然后将其加载到内存中，使得程序可以使用该类的方法和属性。

​	类加载器通常按照一定的层次结构组织，每个类加载器都有一个父类加载器，它们之间形成了一个树形结构。当一个类加载器需要加载某个类时，它首先会委托其父类加载器尝试加载该类，如果父类加载器无法加载该类，那么子类加载器才会尝试加载该类。如果所有的父类加载器都无法加载该类，则该类加载器会尝试自己加载该类。

​	通过类加载器的层次结构，Java 程序可以实现诸如类隔离、动态加载和代码热替换等高级特性。例如，不同的类加载器可以加载同名的类文件，从而实现不同版本的类共存，避免类冲突问题。同时，类加载器也为 Java 应用程序提供了更高的灵活性和可扩展性。



### 2. JVM是如何加载类的？类加载的过程是怎么样的？

- JVM 加载类的过程可以分为三个步骤：加载、连接和初始化。

**1.加载**

类加载是将类的字节码数据加载到 JVM 内部，并在内存中生成一个代表该类的 Class 对象。

**·** 通过类的全限定名（Fully Qualified Name）查找类文件，并读取类文件的二进制数据。

**·** 将类文件的二进制数据转换成内部数据结构，即生成一个代表该类的 Class 对象。

**·** 将 Class 对象放入方法区（Method Area）中，并在堆中创建一个 java.lang.Class 对象，该对象封装了 Class 对象的一些元数据信息。

**2.连接**

连接是将已加载的类和其依赖的类进行链接的过程，包括验证、准备和解析三个步骤。

**·** 验证：验证类的字节码是否符合 JVM 规范，包括检查字节码结构、语义等方面的问题。

**·** 准备：为类的静态变量分配内存空间，并设置默认值。这些变量会在类加载时被创建，但在初始化时才会被赋值。

**·** 解析：将类的符号引用转换成直接引用，即将类名、方法名、字段名等符号引用解析成具体的内存地址。解析通常在初始化之前进行。

**3.初始化**

初始化是执行类构造器（<clinit> 方法），为类的静态变量和静态代码块赋初值的过程。

**·** 静态变量在准备阶段已经分配了内存空间，但此时才会被赋值。

**·** 静态代码块中的代码会在类加载时执行。

**·** 类的初始化由 JVM 自动触发，或者通过程序显式调用 Class 类的静态方法来触发。当 JVM 初始化一个类时，它会先初始化该类的父类（除了 java.lang.Object），然后再依次初始化该类的静态变量和静态代码块。

### 3. 什么是双亲委派模型（Parent Delegation Model）？它是如何保证类的唯一性的？这种模型有什么优点？

​	双亲委派模型（Parent Delegation Model）是一种用于类加载的机制，它是 JVM 中的一个重要特性，也是 Java 语言的核心机制之一。

​	该模型的基本思想是：当一个类加载器要加载一个类时，它首先委托给父类加载器加载，只有当父类加载器无法加载该类时，才会尝试自己加载该类。

​	如果所有的父类加载器都无法加载该类，那么该类最终由最底层的类加载器加载。

​	这种模型可以保证类的唯一性。因为当一个类加载器要加载一个类时，它首先委托给其父类加载器加载。

​	如果该类已经被加载过了，那么它的父类加载器已经将该类加载到了 JVM 中，该类就会直接被返回，不会重新加载。

​	这样就可以避免同一个类被不同的类加载器重复加载，从而保证了类的唯一性。



**优点**

​	**1.可以避免类的重复加载** 由于双亲委派模型的存在，同一个类只会被加载一次，即使它被多个类加载器加载，也只会有一个 Class 对象，这样就避免了类的冲突和重复加载。

​	**2.可以保证类的安全性** 由于双亲委派模型的存在，只有由 JVM 信任的类加载器才能够加载核心类库中的类，而其他的类库只能够使用由 JVM 加载的类库，这样就避免了恶意代码加载系统核心类库，保证了系统的安全性。

​	**3.可以保证类的一致性** 由于双亲委派模型的存在，JVM 中的所有类都是通过父类加载器向上委派加载的，这样就保证了类的一致性，即无论在哪个类加载器中，同一个类都具有相同的 Class 对象，从而可以保证程序的稳定性和可靠性。

### 4. 你知道有哪些不同类型的类加载器吗？它们各自的特点是什么？

​	**1.启动类加载器**（Bootstrap Class Loader）：也称为引导类加载器，它是 Java 虚拟机自身的一部分，负责加载 Java 的核心类库，例如 java.lang 包中的类。它是整个类加载器层次结构的顶层类加载器，由 C++ 实现，不是一个普通的 Java 类，因此无法被 Java 代码直接引用。

​	**2.扩展类加载器**（Extension Class Loader）：也称为系统类加载器，负责加载 Java 虚拟机的扩展类库，例如 java.ext 包中的类。它是启动类加载器的子类，通常由系统属性 “java.ext.dirs” 指定扩展类库的路径。

​	**3.应用程序类加载器**（Application Class Loader）：也称为应用类加载器，负责加载应用程序的类，也就是程序员自己编写的类。它是扩展类加载器的子类，通常由系统属性 “java.class.path” 指定应用程序类库的路径。

​	**4.自定义类加载器**（Custom Class Loader）：除了上述三种内置的类加载器之外，开发者还可以通过继承 java.lang.ClassLoader 类，自定义自己的类加载器。自定义类加载器可以用于实现一些特殊的需求，例如动态加载一些非标准的字节码文件，或者实现类的热替换等功能。

**特点**

​	**1.启动类加载器** 是 Java 虚拟机的一部分，是所有类加载器的父加载器，负责加载 Java 的核心类库，无法被 Java 代码直接引用；

​	**2.扩展类加载器和应用程序类加载器** 是用来加载用户自定义的类的，它们都是普通的 Java 类，都继承自 java.lang.ClassLoader 类，可以被 Java 代码直接引用；

​	**3.自定义类加载器** 可以根据具体需求实现不同的加载策略，例如从网络或者数据库中动态加载类等。每个类加载器都有自己的一套加载规则，它们组成了一个层次结构，通过委托机制来保证类的唯一性和安全性。

### 5. 如果同一个类被不同的类加载器加载了多次，那么这些类之间会有什么不同？

- 如果同一个类被不同的类加载器加载了多次，那么这些类之间会被视为不同的类，即使这些类的字节码是相同的，它们也会被视为不同的类。
- 这是因为在 Java 中，类的唯一性是由类加载器和类全名共同决定的，而不是由类的字节码决定的。不同的类加载器加载同一个类时，会生成不同的类实例，它们有不同的类对象（Class Object），并且被存放在不同的内存空间中。这些类对象在 JVM 中具有不同的地址，因此它们是不同的对象。
- 由于类加载器之间采用了委托机制，如果一个类已经被某个类加载器加载了，其他类加载器就不会再次加载它，而是直接返回已经加载的类的 Class 对象。但是，如果不同的类加载器加载同一个类的字节码时，即使它们加载的字节码是一模一样的，也会生成不同的 Class 对象，从而导致这些类被视为不同的类。
- 这种类的不同性可能会导致一些问题，例如在反射调用时，如果使用不同的类加载器加载了同一个类，就可能会导致类型转换异常等问题。因此，在使用自定义类加载器时，应当避免加载重复的类，以保证程序的正确性和稳定性。

### 6. 如何通过自定义类加载器来实现热部署？

**1.** 热部署是指在应用程序运行期间，对代码进行更新和替换，而不需要重启应用程序。通过自定义类加载器可以实现热部署，主要的实现思路如下：

**2.** 定义自己的类加载器，继承自 Java 提供的 ClassLoader 类。在自定义类加载器中，需要重写 findClass() 方法，该方法用于根据类名加载类的字节码，并生成 Class 对象。

**3.** 在实现热部署时，需要定义一个定时任务，定期地扫描指定目录下的 class 文件，如果发现有修改，就重新加载该类。

**4.** 在重新加载类时，首先需要判断该类是否已经被加载过。如果已经被加载过，需要将该类从 JVM 中卸载，然后再重新加载该类。

**5.** 在重新加载类时，需要使用自定义类加载器来加载类。由于不同的类加载器之间是隔离的，因此使用自定义类加载器加载类，可以确保新的类加载器只加载新的类，而不会影响原来的类。

**6.** 加载新的类后，需要将该类实例化，并使用新的实例替换原来的实例。

需要注意的是，自定义类加载器实现热部署需要考虑到一些问题。例如，在重新加载类时，需要先将原来的类实例化的对象卸载，以免出现内存泄漏等问题；

同时，由于不同的类加载器之间是隔离的，因此需要考虑类加载器的层次关系，以避免类的重复加载。

此外，自定义类加载器实现热部署还需要考虑一些安全问题，例如如何防止恶意代码的注入等。

因此，在实际应用中，需要综合考虑这些因素，来实现可靠的热部署方案。

```java
    import java.io.*;

    public class HotSwapClassLoader extends ClassLoader {

        // 定义要加载的类的路径
        private String classpath;

        public HotSwapClassLoader(String classpath) {
            this.classpath = classpath;
        }

        // 重写 findClass 方法，实现自定义的类加载器逻辑
        @Override
        protected Class<?> findClass(String name) throws ClassNotFoundException {
            // 获取类的字节码
            byte[] classData = getClassData(name);
            if (classData == null) {
                throw new ClassNotFoundException();
            } else {
                // 使用 defineClass 方法将字节码转换为 Class 对象
                return defineClass(name, classData, 0, classData.length);
            }
        }

        // 获取类的字节码
        private byte[] getClassData(String className) {
            String path = classpath + "/" + className.replace('.', '/') + ".class";
            try (InputStream ins = new FileInputStream(path)) {
                ByteArrayOutputStream baos = new ByteArrayOutputStream();
                int bufferSize = 4096;
                byte[] buffer = new byte[bufferSize];
                int bytesNumRead = 0;
                while ((bytesNumRead = ins.read(buffer)) != -1) {
                    baos.write(buffer, 0, bytesNumRead);
                }
                return baos.toByteArray();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return null;
        }

        // 定义一个方法，用于热部署类
        public Class<?> hotSwap(String className) throws ClassNotFoundException {
            // 首先判断该类是否已经被加载过
            Class<?> clazz = findLoadedClass(className);
            if (clazz == null) {
                // 如果该类没有被加载过，则使用自定义类加载器加载该类
                clazz = findClass(className);
            } else {
                // 如果该类已经被加载过，则需要先卸载该类，然后重新加载该类
                try {
                    ClassLoader parent = getParent();
                    parent.loadClass(className);
                    Class<?> newClazz = findClass(className);
                    // 将新的类实例化，并使用新的实例替换原来的实例
                    Object obj = newClazz.newInstance();
                    clazz = newClazz;
                } catch (InstantiationException | IllegalAccessException e) {
                    e.printStackTrace();
                }
            }
            return clazz;
        }
    }
```

上面代码中

先定义了一个 HotSwapClassLoader 类，继承自 ClassLoader 类。在该类中，重写了 findClass() 方法，实现了自定义的类加载器逻辑。

然后定义了 hotSwap() 方法，用于实现热部署。在该方法中，首先判断该类是否已经被加载过。

如果该类没有被加载过，则使用自定义类加载器加载该类；如果该类已经被加载过，则需要先卸载该类，然后重新加载该类。

最后，将新的类实例化，并使用新的实例替换原来的实例。

### 7. JVM的动态代理机制是怎么样的？它是如何使用类加载器来动态生成代理类的？

动态代理机制是利用反射技术在运行时动态生成代理类，这些代理类会实现指定的接口，并将方法调用委托给另一个对象处理。在 Java 中，动态代理主要是通过 java.lang.reflect.Proxy 类和 java.lang.reflect.InvocationHandler 接口实现的。

当我们使用 Proxy 类创建代理对象时，JVM 会动态生成一个代理类，并将该类的字节码加载到内存中。生成代理类的过程主要是通过使用自定义类加载器来完成的，因为默认的类加载器无法加载动态生成的代理类。在 Proxy 类的 getProxyClass() 方法中，JVM 会使用自定义类加载器来加载代理类的字节码。

自定义类加载器主要是继承 java.lang.ClassLoader 类并重写 findClass() 方法。在 findClass() 方法中，我们需要根据类名读取代理类的字节码，并使用 defineClass() 方法将其加载到内存中。为了保证代理类的唯一性，我们可以在自定义类加载器中使用缓存机制，即先查找缓存中是否已经加载过该类，如果没有则从文件中读取并加载到内存中，并将其加入缓存中。

使用动态代理机制的步骤如下：

定义一个接口，该接口中声明需要代理的方法。

1.创建一个实现该接口的目标对象。

2.创建一个 InvocationHandler 对象，用于处理方法调用。

3.使用 Proxy 类的 newProxyInstance() 方法创建代理对象，该方法需要传入目标对象的类加载器、目标对象实现的接口以及 InvocationHandler 对象。

4.调用代理对象的方法，该方法会委托给 InvocationHandler 对象处理。

5.通过使用动态代理机制，我们可以在运行时动态生成代理对象，可以避免写重复的代理类代码，提高代码的复用性和可维护性。同时，由于代理类是动态生成的，我们可以在运行时动态地修改代理对象的行为，实现 AOP（面向切面编程）等高级功能。

```java
	import java.lang.reflect.InvocationHandler;
    import java.lang.reflect.Method;
    import java.lang.reflect.Proxy;

    public class ProxyExample {

        public static void main(String[] args) {
            // 创建一个实现了 Hello 接口的对象
            HelloImpl hello = new HelloImpl();
            // 创建一个 InvocationHandler 对象，用于处理方法调用
            InvocationHandler handler = new MyInvocationHandler(hello);
            // 使用 Proxy 类创建代理对象
            Hello proxy = (Hello) Proxy.newProxyInstance(
                    hello.getClass().getClassLoader(),
                    hello.getClass().getInterfaces(),
                    handler);
            // 调用代理对象的方法
            proxy.sayHello();
        }

        // 定义一个接口
        interface Hello {
            void sayHello();
        }

        // 实现 Hello 接口的类
        static class HelloImpl implements Hello {
            @Override
            public void sayHello() {
                System.out.println("Hello, world!");
            }
        }

        // 实现 InvocationHandler 接口的类，用于处理方法调用
        static class MyInvocationHandler implements InvocationHandler {
            private Object target;

            public MyInvocationHandler(Object target) {
                this.target = target;
            }

            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                System.out.println("Before method invocation.");
                Object result = method.invoke(target, args);
                System.out.println("After method invocation.");
                return result;
            }
        }
    }
```

### 8. 你知道什么是类加载的双向委托模型（Bidirectional Delegation Model）吗？它与双亲委派模型有什么区别？

类加载的双向委托模型（Bidirectional Delegation Model）是 JDK 9 引入的新的类加载机制，它与双亲委派模型有所不同。

在双向委托模型中，除了向父类加载器委托查找类之外，还会向子类加载器委托查找类。这意味着，如果父类加载器无法找到指定的类，它会先向子类加载器询问，如果子类加载器也无法找到该类，那么它再自己查找。如果自己仍然无法找到该类，则会将该请求委托给父类加载器。这种双向委托的方式可以更加灵活地组织类加载器层次结构，避免类加载器之间的强依赖关系。

与双亲委派模型相比，双向委托模型具有以下优点：

**1.更加灵活：** 在双向委托模型中，不仅可以通过向父类加载器委托查找类来实现类的共享，还可以通过向子类加载器委托查找类来实现类的隔离。这种灵活性可以更好地适应不同的应用场景。

**2.更加安全：** 在双向委托模型中，由于父类加载器会优先查找类，因此可以更好地保证类的唯一性和安全性。

**3.更加高效：** 在双向委托模型中，如果子类加载器已经加载了指定的类，父类加载器就不需要再次加载，这可以避免重复加载，提高性能。

需要注意的是，双向委托模型只是一种可选的类加载机制，它并不取代双亲委派模型，而是与其并存。因此，在使用双向委托模型时，仍然需要遵循双亲委派模型的原则，即优先使用父类加载器加载类，以保证类的唯一性和安全性。

### 9. 能否通过JVM参数来修改类加载器的行为？具体是哪些参数？

**-verbose:class** ：打印类加载信息。启用此参数后，JVM 将打印每个类的加载信息，包括类名、类加载器、加载路径等。

**-Xbootclasspath** ：设置启动类路径。启用此参数后，JVM 将优先使用指定的路径加载类。

**-Djava.ext.dirs** ：设置扩展类加载器的搜索路径。启用此参数后，JVM 将搜索指定的路径下的所有 JAR 文件，并将其中的类添加到扩展类加载器的搜索路径中。

**-Xnoclassgc** ：禁用类垃圾回收。启用此参数后，JVM 将不会自动回收无用的类，从而可以避免类被意外卸载，提高性能。

**-XX:+TraceClassLoading** ：跟踪类加载过程。启用此参数后，JVM 将打印每个类的加载信息，包括类名、类加载器、加载路径等，并将其输出到控制台或日志文件中。

### 10. 如何实现一个自定义的类加载器吗？举个例子？

实现自定义的类加载器，我们需要继承 java.lang.ClassLoader 类，并重写 findClass 方法。在该方法中，我们可以根据指定的类名加载类的字节码，并使用 defineClass 方法将其转换成一个 Class 对象。

如下是一个简单的例子：

```java
    import java.io.IOException;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;

    public class MyClassLoader extends ClassLoader {
        private final String classPath;

        public MyClassLoader(String classPath) {
            this.classPath = classPath;
        }

        @Override
        protected Class<?> findClass(String name) throws ClassNotFoundException {
            try {
                byte[] bytes = loadClassData(name);
                return defineClass(name, bytes, 0, bytes.length);
            } catch (IOException e) {
                throw new ClassNotFoundException(name);
            }
        }

        private byte[] loadClassData(String name) throws IOException {
            String fileName = name.replace(".", "/");
            Path path = Paths.get(classPath, fileName + ".class");
            return Files.readAllBytes(path);
        }
    }
```

**1.** 首先定义了一个名为 MyClassLoader 的类，它继承了 ClassLoader 类。

**2.** 接下来在类中定义了一个私有成员变量 classPath，它表示自定义类加载器的类路径。

**3.** 然后在类中定义了一个构造函数 MyClassLoader，它接收一个字符串参数 classPath，并将其赋值给私有成员变量 classPath。

**4.** 接着在类中重写了 findClass 方法，该方法根据类名查找类文件，并将其加载到内存中。如果找不到类文件，则抛出 ClassNotFoundException 异常。

**5.** 在 findClass 方法中，首先调用 loadClassData 方法，该方法读取类文件的字节码内容，并返回一个字节数组。

**6.** 然后调用 defineClass 方法，该方法将字节数组转换成 Class 对象，并返回该对象。这个过程中会执行字节码验证、解析、初始化等操作。

**7.** 最后，定义了一个私有方法 loadClassData，该方法接收一个字符串参数 name，并返回一个字节数组，该数组包含了类文件的字节码内容。在该方法中，我们首先将类名转换成类文件路径，然后使用 java.nio.file 包中的方法读取类文件的字节码内容，并返回该字节数组。

## 4.JVM调优面试题

### 1. JVM中有哪些调优参数？它们的含义是什么？

- 以下是常见的JVM调优参数及其含义的表格形式

| 调优参数                        | 含义                                             |
| ------------------------------- | ------------------------------------------------ |
| -Xms                            | 指定JVM堆内存的初始分配大小                      |
| -Xmx                            | 指定JVM堆内存的最大分配大小                      |
| -XX:NewSize                     | 指定新生代内存的初始大小                         |
| -XX:MaxNewSize                  | 指定新生代内存的最大大小                         |
| -XX:SurvivorRatio               | 指定Eden区与Survivor区的比例，默认为8:1          |
| -XX:MetaspaceSize               | 指定元数据区的初始大小                           |
| -XX:MaxMetaspaceSize            | 指定元数据区的最大大小                           |
| -XX:PermSize                    | 指定永久代的初始大小，只有在JDK7之前的版本才有效 |
| -XX:MaxPermSize                 | 指定永久代的最大大小，只有在JDK7之前的版本才有效 |
| -XX:+UseParallelGC              | 启用并行垃圾回收器                               |
| -XX:+UseConcMarkSweepGC         | 启用CMS垃圾回收器                                |
| -XX:+UseG1GC                    | 启用G1垃圾回收器                                 |
| -XX:ParallelGCThreads           | 指定并行垃圾回收器的线程数                       |
| -XX:ConcGCThreads               | 指定CMS垃圾回收器的并发线程数                    |
| -XX:G1HeapRegionSize            | 指定G1垃圾回收器中的Region大小                   |
| -XX:MaxDirectMemorySize         | 指定直接内存的最大大小                           |
| -XX:+HeapDumpOnOutOfMemoryError | 当JVM发生OutOfMemoryError时，自动生成堆转储文件  |
| -XX:HeapDumpPath                | 指定堆转储文件的存储路径                         |
| -XX:+PrintGCDetails             | 打印垃圾回收的详细信息                           |
| -XX:+PrintGCDateStamps          | 打印垃圾回收的时间戳                             |
| -XX:+PrintHeapAtGC              | 在垃圾回收时打印堆信息                           |
| -XX:+UseCompressedOops          | 启用指针压缩以减少堆内存使用                     |

### 2. 如何设置堆内存大小？

在Java应用程序中，可以通过设置JVM的堆内存大小来控制应用程序对内存的使用。可以使用以下命令行选项来设置JVM的堆内存大小：

- **-Xms**：指定JVM堆内存的初始分配大小。例如，-Xms512m表示将初始分配的堆内存大小设置为512MB。

- **-Xmx**：指定JVM堆内存的最大分配大小。例如，-Xmx1024m表示将最大分配的堆内存大小设置为1GB。

  使用这些选项时，应该注意以下几点：

- 堆内存的大小应该根据应用程序的内存使用情况和可用的系统内存来确定。

- 应该将初始分配的堆内存大小和最大分配的堆内存大小设置为相同的值，以避免JVM在运行时不断地调整堆内存大小。

- 应该避免将堆内存大小设置为超过系统可用内存的大小，否则可能会导致系统崩溃或JVM无法启动。

